* [[/home/shane/var/smulliga/source/git/kubernetes/community/contributors/guide/coding-conventions.md][guide/coding-conventions.md]]
** flags-have-underscores
+ comment :: Flag `{{flagname}}` contains an underscore. Use a dash instead.
+ summary :: Command-line flags should use dashes, not underscores

*** heuristic
Look for variables of type `FlagSet` who's `StringVar` method is run with second parameter being a variable

#+BEGIN_SRC sh
  vim +/"flags.StringVar(.* flagHTTPCacheDir" "$HOME$MYGIT/kubernetes/kubernetes/staging/src/k8s.io/cli-runtime/pkg/genericclioptions/config_flags.go"
#+END_SRC

#+BEGIN_SRC go
  flags *pflag.FlagSet
#+END_SRC

There is a very similar one for ~kubectl~.

*** TODO Make a keybinding to create a github url that highlights the thing at the cursor

| editor | kb                 |
|--------+--------------------|
| vim    | yL                 |
| emacs  | M-y M-L or M-y M-G |

https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/cli-runtime/pkg/genericclioptions/config_flags.go#L18

** well-named-package
+ summary :: Consider parent directory name when choosing a package name. Unless there's a good reason, the `package foo` line should match the name of the directory in which the .go file exists.
+ heuristic :: Capture the filename, the directory name and the package name as variables for the comment. Check that {{packagename}} == {{dirname}}.
+ comment :: Package name does not match the name of the parent directory. Unless there's a good reason, `package {{packagename}}` should match the name of the directory in which {{filename}} file exists, i.e. {{dirname}}.

https://trello.com/c/PSeAQqLs/428-no-fact-for-package-name-unresolved-type-for-ident

*** TODO command heuristic

*** description from readme (aka. doc string / tenet doc)
#+BEGIN_SRC text
  - Please consider parent directory name when choosing a package name.
      - so pkg/controllers/autoscaler/foo.go should say `package autoscaler` not `package autoscalercontroller`.
      - Unless there's a good reason, the `package foo` line should match the name of the directory in which the .go file exists.
      - Importers can use a different name if they need to disambiguate.
#+END_SRC

** well-named-interface
+ summary :: Please consider the package name when selecting an interface name, and avoid redundancy. e.g. `storage.Interface` is better than `storage.StorageInterface`.
+ heuristic :: Check interface names regex and does not include parent directory name. I found one using grep. pkg/controller/nodeipam/ipam/sync/sync.go:175:type syncOp interface {
+ comment :: Interface name {{interfacename}} has name of package {{packagename} redundantly prefixed.

*** search functions
#+BEGIN_SRC sh
  cd "$HOME$MYGIT/kubernetes/kubernetes"; dac -p '\.go$' 'type [A-Za-z]\+[A-Z][a-z] \binterface\b'
  cd "$HOME$MYGIT/kubernetes/kubernetes"; grep -HnP 'type [A-Za-z]+[A-Z][a-z] \binterface\b' **/*.go
#+END_SRC

**** bad interfaces found
#+BEGIN_SRC text
  pkg/controller/nodeipam/ipam/sync/sync.go:175:type syncOp interface {
#+END_SRC

*** description
#+BEGIN_SRC text
  - Please consider package name when selecting an interface name, and avoid redundancy.
      - e.g.: `storage.Interface` is better than `storage.StorageInterface`.
#+END_SRC

*** embedded-lock
 + readme :: [[/home/shane/var/smulliga/source/git/kubernetes/community/contributors/guide/coding-conventions.md][guide/coding-conventions.md]]
 + summary :: Locks should not be embedded

**** search functions
 #+BEGIN_SRC sh
   cd "$HOME$MYGIT/kubernetes/kubernetes"; dac -p '\.go$' -i '\block\b'
   cd "$HOME$MYGIT/kubernetes/kubernetes"; grep -HnP '\block\b' **/*.go
 #+END_SRC

**** description
 #+BEGIN_SRC text
   Locks should be called `lock` and should never be embedded (always `lock sync.Mutex`). When multiple locks are present, give each lock a distinct name following Go conventions - `stateLock`, `mapLock` etc.
 #+END_SRC

** well-named-lock
+ readme :: [[/home/shane/var/smulliga/source/git/kubernetes/community/contributors/guide/coding-conventions.md][guide/coding-conventions.md]]
+ summary :: A lock should be called `lock` unless other locks are present.
+ comment :: There are no other locks besides `{{lockname}}` here. Rename `{{locname}}` to `lock`.
+ heruistic :: When there is only ONE lock inside the same scope, ensure its name is 'lock'.

*** heuristic/go/clql table
| resolution                                             | heuristic                                        | go                                                       | clql                                           | example              |
|--------------------------------------------------------+--------------------------------------------------+----------------------------------------------------------+------------------------------------------------+----------------------|
| consider                                               | multiple locks in same struct                    | [[/home/shane/notes2018/ws/codelingo/issues/kubernetes/well-named-lock/multiple-locks-one-struct.go][well-named-lock/multiple-locks-one-struct.go]]             | [[/home/shane/notes2018/ws/codelingo/issues/kubernetes/well-named-lock/multiple-locks-one-struct.clql][well-named-lock/multiple-locks-one-struct.clql]] |                      |
| consider                                               | lone lock in struct                              |                                                          | [[/home/shane/notes2018/ws/codelingo/issues/kubernetes/well-named-lock/lone-lock-in-file.clql][well-named-lock/lone-lock-in-file.clql]]         |                      |
| write CLQL to search for this, to see if there are any | multiple locks in top-level block                | [[/home/shane/notes2018/ws/codelingo/issues/kubernetes/well-named-lock/multiple-locks-top-level-block.go][well-named-lock/multiple-locks-top-level-block.go]]        |                                                |                      |
| ignore. too difficult to encode with CLQL              | usage of multiple locks in same function         | [[/home/shane/notes2018/ws/codelingo/issues/kubernetes/well-named-lock/usage-of-multiple-locks-same-function.go][well-named-lock/usage-of-multiple-locks-same-function.go]] |                                                |                      |
| ignore.                                                | multiple locks in different structs of same file | [[/home/shane/notes2018/ws/codelingo/issues/kubernetes/well-named-lock/simple-multiple-lock-one-file.go][well-named-lock/simple-multiple-lock-one-file.go]]         |                                                |                      |
| ignore. too few instances.                             | definition of multiple locks in function         | [[/home/shane/notes2018/ws/codelingo/issues/kubernetes/well-named-lock/multiple-locks-in-function.go][well-named-lock/multiple-locks-in-function.go]]            |                                                | [[/home/shane/source/git/kubernetes/kubernetes/pkg/util/async/runner_test.go][async/runner_test.go]] |
| ignore. never happens.                                 | multiple locks in same struct derivative         | [[/home/shane/notes2018/ws/codelingo/issues/kubernetes/well-named-lock/derivative-multiple-lock-one-struct.go][well-named-lock/derivative-multiple-lock-one-struct.go]]   |                                                |                      |

*** Status
[[/home/shane/notes2018/ws/codelingo/issues/kubernetes/troubleshooting/playground-hang.org][troubleshooting/playground-hang.org]]

https://trello.com/c/KV19ScJ9/427-unresolved-type-for-field-inside-lock-pointer

**** Examples
***** multiple locks in function
I only found one instance of this.

#+BEGIN_SRC sh
  vim +/"lock   sync.Mutex" "$HOME/source/git/kubernetes/kubernetes/pkg/util/async/runner_test.go"
#+END_SRC

Remember to factor in Mutext and RWMutex.

*** Example
**** Examples needed
- mutex named lock, in its own struct, in one file
  Need for the 'name' property.
- mutex and rwmutex in the same struct, in the same file
  Need for a query that differentiates two locks.

- mutex on its own in the same file

**** These should be renamed ~lock~.
#+BEGIN_SRC sh
  vim +/"streamLock       sync.Mutex" "$HOME/source/git/kubernetes/kubernetes/staging/src/k8s.io/apimachinery/pkg/util/httpstream/spdy/connection.go"
  vim +/"failuresLock sync.Mutex" "$HOME/source/git/kubernetes/kubernetes/staging/src/k8s.io/client-go/util/workqueue/default_rate_limiters.go"
  vim +/"expirationLock sync.Mutex" "$HOME/source/git/kubernetes/kubernetes/staging/src/k8s.io/client-go/tools/cache/expiration_cache.go"
  # There are cases present in main folders
  vim +/"mutex sync.Mutex" "$HOME/source/git/kubernetes/kubernetes/pkg/util/mount/fake.go"
#+END_SRC

**** These are well named locks
#+BEGIN_SRC sh
  vim +/"lock  sync.RWMutex" "$HOME/source/git/kubernetes/kubernetes/staging/src/k8s.io/client-go/tools/cache/thread_safe_store.go"
  vim +/"lock       sync.Mutex" "$HOME/source/git/kubernetes/kubernetes/staging/src/k8s.io/client-go/tools/cache/mutation_detector.go"
#+END_SRC

**** Are there examples of multiple locks in files named 'lock'?
#+BEGIN_SRC sh
  cd "$HOME$MYGIT/kubernetes/kubernetes"; dac -p '\.go$' -i '^\s\+\block\b\s\+sync\.\(RW\)\?Mutex\b'
#+END_SRC

***** Yes
So I assume that this is OK.
****** Public, In many different structs
[[/home/shane/source/git/kubernetes/kubernetes/pkg/cloudprovider/providers/gce/cloud/gen.go][cloud/gen.go]]

Simplify this and make CLQL out of it.

[[/home/shane/notes2018/ws/codelingo/issues/kubernetes/well-named-lock/simple-multiple-lock-one-file.go][well-named-lock/simple-multiple-lock-one-file.go]]

****** In two different structs
#+BEGIN_SRC sh
  vim +/"lock  sync.Mutex" "$HOME/source/git/kubernetes/kubernetes/staging/src/k8s.io/client-go/plugin/pkg/client/auth/azure/azure.go"
  vim +/"lock      sync.Mutex" "$HOME/source/git/kubernetes/kubernetes/staging/src/k8s.io/client-go/plugin/pkg/client/auth/azure/azure.go"
#+END_SRC

****** In two different structs
#+BEGIN_SRC sh
  vim +/"lock sync.Mutex" "$HOME/source/git/kubernetes/kubernetes/pkg/util/async/bounded_frequency_runner_test.go"
  vim +/"lock   sync.Mutex" "$HOME/source/git/kubernetes/kubernetes/pkg/util/async/bounded_frequency_runner_test.go"
#+END_SRC

*** Plan
**** Query only for *direct* instantiations of sync.RWMutex or synta.Mutex, not for types that inherit a mutex
If you inherit that means you only use one lock. So don't check for this.

**** Look for only definitions of 'lock' which are in the same struct
**** 'Lock' is also OK. I should suggest Lock if the original definition is public

*** CLQL
What queries do I need to construct a robust query?

**** locks that are not part of structs, but is defined as a top-level definition or as part of a function
***** TODO top level defintion
***** TODO part of a function

**** Lone lock in a file. Should be renamed 'lock'.

***** TODO Need to ensure there are no other locks in the file.
****** multiple locks named 'lock' in one file
[[/home/shane/source/git/kubernetes/kubernetes/pkg/cloudprovider/providers/gce/cloud/gen.go][cloud/gen.go]]

Simplify this and make CLQL out of it.

[[/home/shane/notes2018/ws/codelingo/issues/kubernetes/well-named-lock/simple-multiple-lock-one-file.go][well-named-lock/simple-multiple-lock-one-file.go]]
******* CLQL
[[/home/shane/notes2018/ws/codelingo/issues/kubernetes/well-named-lock/simple-multiple-lock-one-file.clql][well-named-lock/simple-multiple-lock-one-file.clql]]

*** DISCARD Should I even consider these files if they lived in ~_vendor~ of the ~spike~ repo?
Only the kubernetes repository is important atm. Check if the file is versioned. Yes it is. It's important.

#+BEGIN_SRC text
  $HOME/source/git/kubernetes/kubernetes/staging/src/k8s.io/client-go/tools/cache/delta_fifo.go

  Spike is a codelingo repository.
  $HOME/source/git/mullikine/spike/k8/_vendor/k8s.io/client-go/tools/cache/delta_fifo.go
#+END_SRC

Search for definitions of the lock within the same scope.

I'm not sure if this is what the raw tenet wanted or if it also considers definitions within a struct of the same file

*** [[/home/shane/notes2018/ws/codelingo/issues/kubernetes/questions.org][kubernetes/questions.org]]

#+BEGIN_SRC go
  closedLock sync.Mutex
#+END_SRC

What about:
For all structs, check if their functions actually need differentiation of lock names.

*** "When multiple locks are present" -- in which context? Within the file? Or within the scope of a struct and its methods?
#+BEGIN_SRC sh
  vim +/"When multiple locks are present" "$HOME/source/git/kubernetes/community/contributors/guide/coding-conventions.md"
#+END_SRC

**** Compose question for kubernetes slack
#+BEGIN_SRC sh
  vim +/"~well-named-locks~" "$HOME/notes2018/ws/codelingo/issues/kubernetes/slack-questions.org"
#+END_SRC

*** progress
**** DISCARD Getting unresolveds. Not sure if tenet is possible
[[/home/shane/notes2018/ws/codelingo/issues/kubernetes/well-named-lock/lock-unlock-verbose-simplified.clql][well-named-lock/lock-unlock-verbose-simplified.clql]]
[[/home/shane/notes2018/ws/codelingo/issues/kubernetes/well-named-lock/lock-unlock-verbose.clql][well-named-lock/lock-unlock-verbose.clql]]

**** TODO Re-evaluate whether or not it's possible

*** search functions
#+BEGIN_SRC sh
  # Don't look for 'lock'...
  cd "$HOME$MYGIT/kubernetes/kubernetes"; dac -p '\.go$' -i '\block\b'
  cd "$HOME$MYGIT/kubernetes/kubernetes"; grep -HnP '\block\b' **/*.go

  # ... Look for Mutex.
  cd "$HOME$MYGIT/kubernetes/kubernetes"; dac -p '\.go$' -i '\bMutex\b'
  # lock.*sync.*sync.RWMutex
  # lock.*sync.Mutex
  # lock.*sync\.\(RW\)\?Mutex

  # This reveals all Mutex definitions -- it's good because I can see if
  # there are multiple in the same file
  cd "$HOME$MYGIT/kubernetes/kubernetes"; dac -p '\.go$' -i 'sync\.\(RW\)\?Mutex\b'
#+END_SRC

*** caveats
**** Sometimes a type that inherits lock is used, rather than instantiating a Mutex directly
#+BEGIN_SRC sh
  vim +/"type FakeWatcher struct {" "$HOME/source/git/kubernetes/kubernetes/staging/src/k8s.io/apimachinery/pkg/watch/watch.go"
  vim +/"type RaceFreeFakeWatcher struct {" "$HOME/source/git/kubernetes/kubernetes/staging/src/k8s.io/apimachinery/pkg/watch/watch.go"
#+END_SRC

**** Mutex and RWMutex together in the same struct are both considered when naming locks
#+BEGIN_SRC sh
  vim +/"lastRequestLock          sync.Mutex" "$HOME/source/git/kubernetes/kubernetes/staging/src/k8s.io/client-go/util/certificate/certificate_manager.go"
  vim +/"certAccessLock           sync.RWMutex" "$HOME/source/git/kubernetes/kubernetes/staging/src/k8s.io/client-go/util/certificate/certificate_manager.go"
#+END_SRC

*** description
#+BEGIN_SRC text
  Locks should be called `lock`. When multiple locks are present, give each lock a distinct name following Go conventions - `stateLock`, `mapLock` etc.
#+END_SRC

** well-named-locks
+ readme :: [[/home/shane/var/smulliga/source/git/kubernetes/community/contributors/guide/coding-conventions.md][guide/coding-conventions.md]]
+ summary :: When multiple locks are present, give each lock a distinct name following Go conventions - `stateLock`, `mapLock` etc.
+ comment :: Multiple locks are present, give each lock a distinct name following Go conventions - `stateLock`, `mapLock` etc.
+ heuristic :: When there is more than one lock inside the same scope, ensure that the names of each lock match the regex '^[a-z]\+\([A-Z][a-z]\+\)*\+Lock$'

*** search functions
#+BEGIN_SRC sh
  cd "$HOME$MYGIT/kubernetes/kubernetes"; grep -HnP '\b[a-z]+([A-Z][a-z]+)*Lock\b' **/*.go
  cd "$HOME$MYGIT/kubernetes/kubernetes"; dac -P -p '\.go$' '\b[a-z]+([A-Z][a-z]+)*Lock\b'
#+END_SRC

*** description
#+BEGIN_SRC text
  Locks should be called `lock`. When multiple locks are present, give each lock a distinct name following Go conventions - `stateLock`, `mapLock` etc.
#+END_SRC

** non-table-driven-test-multiple-scenarios
+ summary :: Table-driven tests are preferred for testing multiple scenarios/inputs
+ comment :: This test case does not appear to be 'table-driven' but multiple inputs / scenarios are being tested. Consider using a table-driven approach.
+ heuristic :: http://mullikine.github.io/codelingo/table-driven-test-kubernetes.html

| difficulty |
|------------|
| hard       |

*** TODO Ask on slack #kubernetes what to look for when statically checking if a test case uses multiple inputs / tests multiple scenarios.
[[/home/shane/notes2018/ws/codelingo/issues/kubernetes/slack-questions.org][kubernetes/slack-questions.org]]

*** description
#+BEGIN_SRC text
  Table-driven tests are preferred for testing multiple scenarios/inputs; for example, see TestNamespaceAuthorization at https://git.k8s.io/kubernetes/test/integration/auth/auth_test.go
#+END_SRC

** new-package-requires-test
+ readme :: [[/home/shane/var/smulliga/source/git/kubernetes/community/contributors/guide/coding-conventions.md][guide/coding-conventions.md]]
+ summary :: All new packages must come with unit tests.
+ comment :: The package {{packageName}} is not unit tested. Please write either an integration (test/integration) and/or an end-to-end (test/e2e) test that tests it.
+ heuristic :: Ensure each package has an associated unit test. This might have to be limited to a subset due to the 'new' packages instruction. How to find that a package has been tested?
+ docstring :: All new packages and most new significant functionality must come with unit tests

*** Search functions
#+BEGIN_SRC sh
  cd "$HOME/source/git/kubernetes/kubernetes/test"; grep "^package " **/*.go
  cd "$HOME/source/git/kubernetes/kubernetes/test"; grep "^package " **/*.go | vs

  # Must grep for packages in the main directories -- uses zsh exclude
  cd "$HOME/source/git/kubernetes/kubernetes"; grep "^package " ^test/**/*.go | vs
#+END_SRC

But how will I ensure that a package name is unique? It actually doesn't have to be unique within the project, or does it?

#+BEGIN_SRC sh
  # ✗ This is NOT what I want to do to find usages of packages
  cd "$HOME/source/git/kubernetes/kubernetes"; grep "^package " test/**/*.go | cut -d : -f 2 | uniq

  # ✓ This is what I want to do to find the usages of packages
  cd "$HOME/source/git/kubernetes/kubernetes"; grep "^import " test/**/*.go | v

  # ✓ Find the package definitions outside of the test folder
  cd "$HOME/source/git/kubernetes/kubernetes"; grep "^package " ^test/**/*.go | cut -d : -f 2 | uniq
#+END_SRC

See the diff

#+BEGIN_SRC sh
  cd "$HOME/source/git/kubernetes/kubernetes"; grep "^package " ^(test|third_party)/**/*.go | cut -d : -f 2 | cut -d ' ' -f 2 | sort | uniq | ds k8packages | vs

  # This is not going to produce an accurate diff. I need to extract all the import blocks from all of the files.
  cd "$HOME/source/git/kubernetes/kubernetes"; grep "^package " test/**/*.go | cut -d : -f 2 | cut -d ' ' -f 2 | sort | uniq | ds k8testpackages | vs
  vd <(gs k8packages) <(gs k8testpackages)

  # This is better, although it shows we have a bunch of packages that are imported from the external world, which will not be in the test suite.
  # No matter. We only need to test that the packages defined outside the test folder are not used inside the test folder
  find "$HOME/source/git/kubernetes/kubernetes/test" -name '*.go' -exec cat {} \; | go-extract-imports | sort | uniq | ds k8testpackages | vs
  gs k8testpackages | vs
#+END_SRC

I probably only need to check if it's used inside here:

~k8s.io/kubernetes/~

#+BEGIN_SRC text
  The tenet im currently writing up mentions only new packages require a new unit test. i did a search and there are about 680 of 700 untested packages in kubernetes and im wondering how i should approach this one. do we have plans to make tenets which apply only to PRs?
  I may have exaggerated those figures with my naive grepping. but still im wondering about whether i should make this tenet look for all untested packages.
  Silly question. Just use a codelingoigore
#+END_SRC

** significant-command-feature-needs-test
+ readme :: [[/home/shane/var/smulliga/source/git/kubernetes/community/contributors/guide/coding-conventions.md][guide/coding-conventions.md]]
+ summary :: Significant command features should come with an integration and/or end-to-end (e2e) test.
+ heuristic :: Do all kubectl commands and kubernetes command features have either a unit test or an e2e test?

*** description
#+BEGIN_SRC text
  - Significant features should come with integration (test/integration) and/or [end-to-end (test/e2e) tests](/contributors/devel/e2e-tests.md)
    - Including new kubectl commands and major features of existing commands
#+END_SRC

*** Heuristics / search functions
#+BEGIN_SRC sh
  cd "$HOME/source/git/kubernetes/kubernetes"; ead NewFlagSet
#+END_SRC