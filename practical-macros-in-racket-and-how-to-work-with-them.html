<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2018-10-14 Sun 22:08 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Practical macros in Racket</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Kevin R. Stravers" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="org-main.css"/>
<link rel="stylesheet" type="text/css" href="magit.css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Practical macros in Racket
<br />
<span class="subtitle">and how to work with them</span>
</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org59e6f9d">1. Read the original article <span class="underline">here</span>.</a></li>
<li><a href="#org0779581">2. Practical macros in Racket and how to work with them</a></li>
<li><a href="#orgb3adb08">3. What's all this racket?</a></li>
<li><a href="#org444cb3d">4. <span class="done DISCARD">DISCARD</span> <code>syntax-case</code> (the <b>typeless</b> version of <code>syntax-parse</code>). Don't use it!</a>
<ul>
<li><a href="#org5be03d1">4.1. If you do use <code>syntax-case</code> then you can (and should) use <code>with-syntax</code> too</a>
<ul>
<li><a href="#org16d85f4">4.1.1. <code>with-syntax</code> very similar to <i>(but should be used alongside)</i> <code>syntax-case</code></a></li>
<li><a href="#org302689d">4.1.2. Examples: <code>#:with</code> vs <code>with-syntax</code> for use with <code>define-syntax-parser</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgcc4f4e2">5. <span class="todo TODO">TODO</span> Learn to use the <code>syntax-parse</code> family</a>
<ul>
<li><a href="#org2446c58">5.1. Example A: (most concise). Uses <code>define-syntax-parser</code></a></li>
<li><a href="#orgb0a0897">5.2. Perfectly fine example B: (expanded). Uses <code>define-syntax</code></a></li>
<li><a href="#org5572bc2">5.3. Perfectly fine example C: (shorthand). Uses <code>define-syntax</code></a></li>
<li><a href="#orgfa9f87d">5.4. <code>define-syntax-parser</code> vs shorthand <code>define-syntax</code></a></li>
</ul>
</li>
<li><a href="#orgbf279d6">6. <code>make-rename-transformer</code></a></li>
<li><a href="#orgcadbbe8">7. <code>make-set!-transformer</code></a></li>
<li><a href="#org452502e">8. Syntax taints, what are they?</a></li>
<li><a href="#org52a5336">9. Literals</a></li>
<li><a href="#orga491638">10. Experimenting with the lowest level</a></li>
<li><a href="#org0106dc2">11. Syntax parameters, what are they for?</a></li>
<li><a href="#org0ac2090">12. I don't get it, how does <code>syntax-parse</code> work?</a>
<ul>
<li><a href="#orgb93d74b">12.1. Another cool thing: you can run arbitrary code in the body:</a></li>
<li><a href="#org9ac2571">12.2. There are also some special pattern forms:</a>
<ul>
<li><a href="#org9d00f51">12.2.1. Table of forms</a></li>
<li><a href="#org3e85d3c">12.2.2. They can even be nested</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgedb47ef">13. Read the original article <span class="underline">here</span>.</a></li>
<li><a href="#org2cb1be4">14. Take-away notes</a>
<ul>
<li><a href="#orgd4a360e">14.1. parts of syntax</a></li>
<li><a href="#orga050531">14.2. syntax transformer families</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org59e6f9d" class="outline-2">
<h2 id="org59e6f9d"><span class="section-number-2">1</span> Read the original article <a href="https://kevin.stravers.net/2017/11/practical-macros-in-racket-and-how-to-work-with-them.html"><span class="underline">here</span></a>.</h2>
<div class="outline-text-2" id="text-1">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">Written by:</td>
<td class="org-left"><b>Kevin R. Stravers</b></td>
<td class="org-left"><span class="timestamp-wrapper"><span class="timestamp">&lt;2017-11-17 Fri&gt;</span></span></td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org0779581" class="outline-2">
<h2 id="org0779581"><span class="section-number-2">2</span> Practical macros in Racket and how to work with them</h2>
<div class="outline-text-2" id="text-2">
<p>
A macro is central in any Lisp and must be mastered in order to master
the language. However, Racket is in a state of macro chaos - at least in
the official documentation. There's <code>define-syntax-rule</code>, <code>syntax-parse</code>,
<code>syntax-case</code>, and so many more. How do we make sense of it? In this
tutorial we'll investigate syntax transformers in Racket so we can get a
complete picture.
</p>
</div>
</div>

<div id="outline-container-orgb3adb08" class="outline-2">
<h2 id="orgb3adb08"><span class="section-number-2">3</span> What's all this racket?</h2>
<div class="outline-text-2" id="text-3">
<p>
I've looked through the racket documentation and connected most of the
syntax transformers there. Here are the biggest ones and some utility
functions.
</p>


<div id="orgfee90ed" class="figure">
<p><img src="macro-graph.png" alt="macro-graph.png" />
</p>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">symbol</th>
<th scope="col" class="org-left">meaning</th>
<th scope="col" class="org-left">example</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><span class="underline"><b>Arrows</b></span></td>
<td class="org-left">Denote that <code>one</code> <i>(<code>-&gt;</code> can be defined in terms of)</i> <code>the other</code></td>
<td class="org-left"><code>define-simple-macro</code> <i>(<code>-&gt;</code> can be defined in terms of)</i> <code>define-syntax-parser</code>.</td>
</tr>

<tr>
<td class="org-left"><span class="underline"><b>Red boxes</b></span></td>
<td class="org-left">Indicate what I believe to be important <span class="underline">tools</span></td>
<td class="org-left"><code>define-syntax-parser</code>, <code>define/syntax-parse</code>, <code>syntax-protect</code>, <code>make-set!-transformer</code></td>
</tr>

<tr>
<td class="org-left"><span class="underline"><b>circles</b></span></td>
<td class="org-left">Denote important <span class="underline">syntax primitives</span>.</td>
<td class="org-left"><code>define-syntax</code>, <code>syntax-parse</code>, <code>syntax-case</code></td>
</tr>

<tr>
<td class="org-left">Bold boxes</td>
<td class="org-left">Important but not essential.</td>
<td class="org-left"><code>define-syntaxes</code>, <code>begin-for-syntax</code>, <code>define-simple-macro</code>, <code>syntax-parser</code></td>
</tr>

<tr>
<td class="org-left">Normal boxes</td>
<td class="org-left">Not that important, but good to know.</td>
<td class="org-left"><code>define</code>, <code>syntax-arm</code>, <code>local-expand</code>, <code>free-identifier=?</code></td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">Dashed boxes</td>
<td class="org-left">Unimportant tools that ought to be deprecated.</td>
<td class="org-left"><code>define-syntax-rule</code>, <code>syntax-rules</code>, <code>with-syntax</code>, <code>with-syntax*</code>, <code>define-with-syntax</code>, <code>syntax-id-rules</code></td>
</tr>
</tbody>
</table>

<p>
For the new macro programmer this is quite a lot to take in, and there's
a myriad of other tools that supplement these, but I can safely say that
you can ignore everything except <code>define-syntax-parser</code> if you're new.
Why? Because it's a typechecking syntax transformer and allows you to
manipulate syntax in a complex manner. It also prevents you from having
to use <code>define-syntax</code> together with <code>syntax-parse</code>. In essence it's a way
to define macros in a clean manner.
</p>
</div>
</div>

<div id="outline-container-org444cb3d" class="outline-2">
<h2 id="org444cb3d"><span class="section-number-2">4</span> <span class="done DISCARD">DISCARD</span> <code>syntax-case</code> (the <b>typeless</b> version of <code>syntax-parse</code>). Don't use it!</h2>
<div class="outline-text-2" id="text-4">
<dl class="org-dl">
<dt><code>syntax-case</code></dt><dd><span class="underline">Sucks</span> because you must write additional code to check the type during <i>macro</i>-time.</dd>
<dt><code>syntax-parse</code></dt><dd><span class="underline">Rules</span> because you can assert that a term is an <i>identifier</i> <b>or</b> a <i>keyword</i> in a declarative manner.</dd>
</dl>

<hr />

<ul class="org-ul">
<li>There are also some other differences in how <span class="underline">arguments are applied</span> and <span class="underline">errors are reported</span>.</li>

<li><code>syntax-parse</code> is widely superior to <code>syntax-case</code>.</li>
</ul>
</div>

<div id="outline-container-org5be03d1" class="outline-3">
<h3 id="org5be03d1"><span class="section-number-3">4.1</span> If you do use <code>syntax-case</code> then you can (and should) use <code>with-syntax</code> too</h3>
<div class="outline-text-3" id="text-4-1">
</div>
<div id="outline-container-org16d85f4" class="outline-4">
<h4 id="org16d85f4"><span class="section-number-4">4.1.1</span> <code>with-syntax</code> very similar to <i>(but should be used alongside)</i> <code>syntax-case</code></h4>
<div class="outline-text-4" id="text-4-1-1">
<p>
<code>with-syntax</code> is part of the same family of <b><span class="underline"><a href="http://racket/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._with-syntax))">Pattern-Based Syntax Matching</a></span></b> forms as <code>syntax-case</code> and is nearly identical to <code>syntax-case</code> under the hood:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><b>Similar</b> to <code>syntax-case</code></td>
<td class="org-left">it matches a pattern to a syntax object</td>
</tr>

<tr>
<td class="org-left"><b>Unlike</b> <code>syntax-case</code></td>
<td class="org-left">all patterns are matched, each to the result of a corresponding <code>stx-expr</code></td>
</tr>
</tbody>
</table>

<p>
The <b>result</b> of the <code>with-syntax</code> form is the result of the <span class="underline">last body</span>, which is in tail position with respect to the <code>with-syntax</code> form. This is what <code>syntax-case</code> does too.
</p>

<hr />

<p>
But don't use <code>with-syntax</code> anywhere else!
</p>
<ul class="org-ul">
<li><code>with-syntax</code> is incredibly useful in <code>syntax-case</code>, but</li>
<li>inside <code>syntax-parse</code> we should use <code>#:with</code> instead.</li>
</ul>
</div>
</div>

<div id="outline-container-org302689d" class="outline-4">
<h4 id="org302689d"><span class="section-number-4">4.1.2</span> Examples: <code>#:with</code> vs <code>with-syntax</code> for use with <code>define-syntax-parser</code></h4>
<div class="outline-text-4" id="text-4-1-2">
<p>
The advantage of <code>#:with</code> over <code>with-syntax</code> is the use of types and better
error reporting for <code>syntax-parse</code>.
</p>
</div>

<ol class="org-ol">
<li><a id="org8687d8a"></a><code>#:with</code><br />
<div class="outline-text-5" id="text-4-1-2-1">
<div class="org-src-container">
<pre class="src src-racket" id="org304cf40">(<span style="color: #a1db00;">require</span> syntax/parse/define)

(define-syntax-parser <span style="color: #ff8700;">with-example</span>
  [(<span style="color: #a1db00;">_</span> a)
   <span style="color: #cd5c5c;">#:with</span> (b:id <span style="color: #a1db00;">...</span>) #'(one two three)
   #'(<span style="color: #d18aff;">list</span> a <span style="color: #2e8b57;">'b</span> <span style="color: #a1db00;">...</span>)])

(with-example <span style="color: #2e8b57;">'zero</span>)
<span style="color: #6c6c6c; font-style: italic;">; </span><span style="color: #6c6c6c; font-style: italic;">'(zero one two three)</span>
</pre>
</div>
</div>
</li>

<li><a id="org6b4f2a8"></a><code>with-syntax</code><br />
<div class="outline-text-5" id="text-4-1-2-2">
<div class="org-src-container">
<pre class="src src-racket" id="org60893e4">(<span style="color: #a1db00;">require</span> syntax/parse/define)

(define-syntax-parser <span style="color: #ff8700;">with-example</span>
  [(<span style="color: #a1db00;">_</span> a)
   (<span style="color: #a1db00;">with-syntax</span> ([(b <span style="color: #a1db00;">...</span>) #'(one two three)])
     #'(<span style="color: #d18aff;">list</span> a <span style="color: #2e8b57;">'b</span> <span style="color: #a1db00;">...</span>))])

(with-example <span style="color: #2e8b57;">'zero</span>)
<span style="color: #6c6c6c; font-style: italic;">; </span><span style="color: #6c6c6c; font-style: italic;">'(zero one two three)</span>
</pre>
</div>
</div>
</li>

<li><a id="org0928550"></a><code>#:with</code> vs <code>with-syntax</code><br />
<div class="outline-text-5" id="text-4-1-2-3">
<ul class="org-ul">
<li><code>with-syntax</code> uses more parentheses.</li>
<li><code>#:with</code> specifies type <code>:id</code> for <code>b</code></li>
</ul>

<div class="org-src-container">
    <pre class="src">
 (define-syntax-parser with-example
   [(_ a)
</span><span class="magit-diff-removed">-   </span><span class="magit-diff-removed"><span class="diff-refine-removed">#:</span></span><span class="magit-diff-removed">with (b</span><span class="magit-diff-removed"><span class="diff-refine-removed">:id</span></span><span class="magit-diff-removed"> ...) #'(one two three)
-   #'(list a 'b ...)])
</span><span class="magit-diff-added">+   </span><span class="magit-diff-added"><span class="diff-refine-added">(</span></span><span class="magit-diff-added">with</span><span class="magit-diff-added"><span class="diff-refine-added">-syntax</span></span><span class="magit-diff-added"> (</span><span class="magit-diff-added"><span class="diff-refine-added">[(</span></span><span class="magit-diff-added">b ...) #'(one two three)</span><span class="magit-diff-added"><span class="diff-refine-added">])</span></span><span class="magit-diff-added">
+     #'(list a 'b ...</span><span class="magit-diff-added"><span class="diff-refine-added">)</span></span><span class="magit-diff-added">)])
</span>
</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-orgcc4f4e2" class="outline-2">
<h2 id="orgcc4f4e2"><span class="section-number-2">5</span> <span class="todo TODO">TODO</span> Learn to use the <code>syntax-parse</code> family</h2>
<div class="outline-text-2" id="text-5">
<p>
<code>syntax-parse</code> is the primitive of the most advanced syntax transformer in
racket (as far as I know). Here are some examples of how to use <code>syntax-parse</code>.
</p>

<div class="org-src-container">
<pre class="src src-racket"><span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">Remember to require this</span>
(<span style="color: #a1db00;">require</span> syntax/parse syntax/parse/define)

<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">Or do you do this? -- either/or I guess</span>
(<span style="color: #a1db00;">require</span> syntax/parse/define (<span style="color: #a1db00;">for-syntax</span> racket))
</pre>
</div>
</div>

<div id="outline-container-org2446c58" class="outline-3">
<h3 id="org2446c58"><span class="section-number-3">5.1</span> Example A: (most concise). Uses <code>define-syntax-parser</code></h3>
<div class="outline-text-3" id="text-5-1">
<p>
Most of the time we want to use <code>define-syntax-parser</code> because it saves us the effort of typing <code>syntax-parse</code> and <code>stx</code>, as in the examples that follow.
</p>

<div class="org-src-container">
<pre class="src src-racket">
(define-syntax-parser <span style="color: #ff8700;">name</span>
  [(<span style="color: #a1db00;">_</span> a b ...+)
   #'(<span style="color: #d18aff;">+</span> a (<span style="color: #d18aff;">-</span> b <span style="color: #a1db00;">...</span>))])

(name <span style="color: #2e8b57;">1</span> <span style="color: #2e8b57;">2</span> <span style="color: #2e8b57;">3</span> <span style="color: #2e8b57;">4</span>)
<span style="color: #6c6c6c; font-style: italic;">; </span><span style="color: #6c6c6c; font-style: italic;">-4</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb0a0897" class="outline-3">
<h3 id="orgb0a0897"><span class="section-number-3">5.2</span> Perfectly fine example B: (expanded). Uses <code>define-syntax</code></h3>
<div class="outline-text-3" id="text-5-2">
<p>
This is an expanded version of the above.
</p>

<div class="org-src-container">
<pre class="src src-racket">(<span style="color: #a1db00;">define-syntax</span> (<span style="color: #ffd700;">name</span> stx)
  (<span style="color: #d18aff;">syntax-parse</span> stx
    [(<span style="color: #a1db00;">_</span> a b ...+)
     #'(<span style="color: #d18aff;">+</span> a (<span style="color: #d18aff;">-</span> b <span style="color: #a1db00;">...</span>))]))

(name <span style="color: #2e8b57;">1</span> <span style="color: #2e8b57;">2</span> <span style="color: #2e8b57;">3</span> <span style="color: #2e8b57;">4</span>)
<span style="color: #6c6c6c; font-style: italic;">; </span><span style="color: #6c6c6c; font-style: italic;">-4</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org5572bc2" class="outline-3">
<h3 id="org5572bc2"><span class="section-number-3">5.3</span> Perfectly fine example C: (shorthand). Uses <code>define-syntax</code></h3>
<div class="outline-text-3" id="text-5-3">
<ul class="org-ul">
<li><code>stx</code> is inferred here</li>
</ul>
<div class="org-src-container">
<pre class="src src-racket">(<span style="color: #a1db00;">define-syntax</span> <span style="color: #ff8700;">name</span>
  (<span style="color: #d18aff;">syntax-parser</span>
    [(<span style="color: #a1db00;">_</span> a b ...+)
     #'(<span style="color: #d18aff;">+</span> a (<span style="color: #d18aff;">-</span> b <span style="color: #a1db00;">...</span>))]))

(name <span style="color: #2e8b57;">1</span> <span style="color: #2e8b57;">2</span> <span style="color: #2e8b57;">3</span> <span style="color: #2e8b57;">4</span>)
<span style="color: #6c6c6c; font-style: italic;">; </span><span style="color: #6c6c6c; font-style: italic;">-4</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgfa9f87d" class="outline-3">
<h3 id="orgfa9f87d"><span class="section-number-3">5.4</span> <code>define-syntax-parser</code> vs shorthand <code>define-syntax</code></h3>
<div class="outline-text-3" id="text-5-4">
<div class="org-src-container">
    <pre>
<span class="magit-diff-removed">-(define-syntax-parser </span><span class="magit-diff-removed"><span class="diff-refine-removed">name</span></span><span class="magit-diff-removed">
-  [(_ a b ...+)
-   #'(+ a (- b ...))])
</span><span class="magit-diff-added">+(define-syntax </span><span class="magit-diff-added"><span class="diff-refine-added">name
+  (syntax</span></span><span class="magit-diff-added">-parser
+    [(_ a b ...+)
+     #'(+ a (- b ...))]</span><span class="magit-diff-added"><span class="diff-refine-added">)</span></span><span class="magit-diff-added">)
</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgbf279d6" class="outline-2">
<h2 id="orgbf279d6"><span class="section-number-2">6</span> <code>make-rename-transformer</code></h2>
<div class="outline-text-2" id="text-6">
<p>
This special transformer is basically an alias that preserves identifier
equality.
</p>

<div class="org-src-container">
<pre class="src src-racket">(<span style="color: #a1db00;">define-syntax</span> <span style="color: #ff8700;">l</span> (<span style="color: #d18aff;">make-rename-transformer</span> #<span style="color: #2e8b57;">'let</span>))
(<span style="color: #a1db00;">let</span> ([<span style="color: #ff8700;">a</span> <span style="color: #2e8b57;">1</span>] [<span style="color: #ff8700;">b</span> <span style="color: #2e8b57;">2</span>]) (<span style="color: #d18aff;">+</span> a b))
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">3</span>

(l ([a <span style="color: #2e8b57;">1</span>] [b <span style="color: #2e8b57;">2</span>]) (<span style="color: #d18aff;">+</span> a b))
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">3</span>

(<span style="color: #d18aff;">free-identifier=?</span> #<span style="color: #2e8b57;">'let</span> #<span style="color: #2e8b57;">'l</span>)
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">#t</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgcadbbe8" class="outline-2">
<h2 id="orgcadbbe8"><span class="section-number-2">7</span> <code>make-set!-transformer</code></h2>
<div class="outline-text-2" id="text-7">
<p>
Another special transformer is the <code>set!-transformer</code>, it allows you to
transform a mutation of an identifier.
</p>

<div class="org-src-container">
<pre class="src src-racket">(<span style="color: #a1db00;">define</span> <span style="color: #ff8700;">a</span> <span style="color: #2e8b57;">0</span>)
(<span style="color: #a1db00;">define</span> <span style="color: #ff8700;">b</span> <span style="color: #2e8b57;">1</span>)

(<span style="color: #a1db00;">let-syntax</span> ([<span style="color: #ff8700;">a</span> (<span style="color: #d18aff;">make-set!-transformer</span>
                 (<span style="color: #d18aff;">syntax-parser</span> <span style="color: #cd5c5c;">#:literals</span> (<span style="color: #a1db00;">set!</span>)
                                [(<span style="color: #a1db00;">set!</span> <span style="color: #a1db00;">_</span> v) #'(<span style="color: #a1db00;">set!</span> b v)]
                                [i:id #<span style="color: #2e8b57;">'a</span>]))])
  (<span style="color: #a1db00;">set!</span> a <span style="color: #2e8b57;">2</span>)
  (<span style="color: #d18aff;">list</span> a b))

<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">'(0 2)</span>
</pre>
</div>

<p>
I haven't had much use for this in my code so far, but I guess it's fine
to keep in mind in case you need it.
</p>
</div>
</div>

<div id="outline-container-org452502e" class="outline-2">
<h2 id="org452502e"><span class="section-number-2">8</span> Syntax taints, what are they?</h2>
<div class="outline-text-2" id="text-8">
<p>
The documentation on syntax taints is confusing to me. Here's my
synopsis: It prevents the arbitrary use of identifiers: if you extract
any part of another macro's armed result, then that extracted part is
tainted and can't be used further. Allow me to exemplify:
</p>

<p>
Examples:
</p>

<div class="org-src-container">
<pre class="src src-racket">(<span style="color: #a1db00;">require</span> syntax/parse/define)

(define-syntax-parser <span style="color: #ff8700;">a</span>
  [(<span style="color: #a1db00;">_</span>) (<span style="color: #d18aff;">syntax-protect</span> #'(c))])
<span style="color: #6c6c6c; font-style: italic;">; </span><span style="color: #6c6c6c; font-style: italic;">(c) is armed here</span>

(define-syntax-parser <span style="color: #ff8700;">b</span>
  [(<span style="color: #a1db00;">_</span>)
   <span style="color: #6c6c6c; font-style: italic;">; </span><span style="color: #6c6c6c; font-style: italic;">c is extracted from (c), which taints the result c</span>
   <span style="color: #cd5c5c;">#:with</span> d (<span style="color: #d18aff;">car</span> (<span style="color: #d18aff;">syntax-e</span> (<span style="color: #d18aff;">local-expand</span> #'(a) <span style="color: #2e8b57;">'expression</span> <span style="color: #2e8b57;">#f</span>)))
   <span style="color: #6c6c6c; font-style: italic;">; </span><span style="color: #6c6c6c; font-style: italic;">the macro expander inserts d which results in #'(+ TAINTED:c),</span>
   <span style="color: #6c6c6c; font-style: italic;">; </span><span style="color: #6c6c6c; font-style: italic;">so the expander rejects this</span>
   #'(<span style="color: #d18aff;">+</span> d)])

(b)
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">eval:22:0: #%top: cannot use identifier tainted by macro</span>
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">transformation</span>
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">in: #%top</span>
</pre>
</div>

<p>
This rejects the expression <code>(+ c)</code> because the identifier <code>c</code> is <b>tainted</b>.
Why is it tainted? Because <code>syntax-e</code> tainted it. Why did it taint it?
Because the <code>syntax-object</code> was <b>armed</b>.
</p>

<div class="org-src-container">
<pre class="src src-racket">(<span style="color: #a1db00;">require</span> syntax/parse/define)
(<span style="color: #a1db00;">define</span> <span style="color: #ff8700;">c</span> <span style="color: #2e8b57;">10</span>)

(define-syntax-parser <span style="color: #ff8700;">a</span>
  [(<span style="color: #a1db00;">_</span>) (<span style="color: #d18aff;">syntax-protect</span> #<span style="color: #2e8b57;">'c</span>)])

(define-syntax-parser <span style="color: #ff8700;">b</span>
  [(<span style="color: #a1db00;">_</span>)
   <span style="color: #cd5c5c;">#:with</span> d #'(a)
   #'(<span style="color: #d18aff;">displayln</span> d)])

(b)
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">10</span>
</pre>
</div>

<p>
This shows that the expander
</p>
<ul class="org-ul">
<li>accepts
<ul class="org-ul">
<li><i>armed</i>, and</li>
<li><i>clean</i> syntax objects, but</li>
</ul></li>
<li>rejects
<ul class="org-ul">
<li><i>tainted</i> syntax objects.</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org52a5336" class="outline-2">
<h2 id="org52a5336"><span class="section-number-2">9</span> Literals</h2>
<div class="outline-text-2" id="text-9">
<p>
<code>syntax-parse</code> allows the use of literals:
</p>

<div class="org-src-container">
<pre class="src src-racket">(<span style="color: #a1db00;">require</span> syntax/parse/define)

(define-syntax-parser <span style="color: #ff8700;">my-parser</span>
  <span style="color: #cd5c5c;">#:datum-literals</span> (a-word)
  [(<span style="color: #a1db00;">_</span> a-word b-word)
   #'(<span style="color: #a1db00;">begin</span>
       (<span style="color: #d18aff;">displayln</span> <span style="color: #2e8b57;">'a-word</span>)
       (<span style="color: #d18aff;">displayln</span> <span style="color: #2e8b57;">'b-word</span>))])

(my-parser a-word <span style="color: #2e8b57;">10</span>)

a-word
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">10</span>
</pre>
</div>

<p>
<code>#:literals</code> is also possible. Then there's a need for an identifier to
exist in the enclosing phase:
</p>

<div class="org-src-container">
<pre class="src src-racket">(define-syntax-parser <span style="color: #ff8700;">my-parser</span>
  <span style="color: #cd5c5c;">#:literals</span> (is-this-bound?)
  [(<span style="color: #a1db00;">_</span> is-this-bound? b-word)
   #'(<span style="color: #a1db00;">begin</span>
       (<span style="color: #d18aff;">displayln</span> <span style="color: #2e8b57;">'a-word</span>)
       (<span style="color: #d18aff;">displayln</span> <span style="color: #2e8b57;">'b-word</span>))])

(my-parser is-this-bound? <span style="color: #2e8b57;">10</span>)
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">eval:33:0: syntax-parser: literal is unbound in phase 0</span>
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">(phase 0 relative to the enclosing module)</span>
<span style="color: #6c6c6c; font-style: italic;">;;   </span><span style="color: #6c6c6c; font-style: italic;">at: is-this-bound?</span>
<span style="color: #6c6c6c; font-style: italic;">;;   </span><span style="color: #6c6c6c; font-style: italic;">in: (syntax-parser #:literals (is-this-bound?) ((_</span>
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">is-this-bound? b-word) (syntax (begin (displayln (quote</span>
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">a-word)) (displayln (quote b-word))))))</span>
</pre>
</div>

<p>
We can use literals to discriminate between real and fake identifiers:
</p>

<div class="org-src-container">
<pre class="src src-racket">(define-syntax-parser <span style="color: #ff8700;">is-it-let?</span>
  [(<span style="color: #a1db00;">_</span> (~literal <span style="color: #a1db00;">let</span>)) #<span style="color: #2e8b57;">'#t</span>]
  [(<span style="color: #a1db00;">_</span> (~datum <span style="color: #a1db00;">let</span>)) #<span style="color: #2e8b57;">'#f</span>]
  [<span style="color: #a1db00;">_</span> #<span style="color: #2e8b57;">'#f</span>])

(is-it-let? <span style="color: #a1db00;">let</span>)
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">#t</span>

(<span style="color: #a1db00;">let</span> ([<span style="color: #ff8700;">let</span> <span style="color: #2e8b57;">0</span>])
  (is-it-let? <span style="color: #a1db00;">let</span>))
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">#f</span>
</pre>
</div>

<p>
Note that <code>(~literal x)</code> as a pattern is the same as specifying <code>#:literals
(x)</code> as keyword argument and using <code>x</code> as a pattern. Similarly for
<code>#:datum-literals (x)</code>.
</p>
</div>
</div>

<div id="outline-container-orga491638" class="outline-2">
<h2 id="orga491638"><span class="section-number-2">10</span> Experimenting with the lowest level</h2>
<div class="outline-text-2" id="text-10">
<p>
Using <code>define-syntax</code> we can define simple functions that are essentially
macros that don't pattern match. This style allows you to get to know
the low-level API, and I believe it to be very important to experiment
with to understand what <code>syntax-parse</code> is actually doing.
</p>

<p>
Vision is the most important thing, let's look at what's going on!
</p>

<div class="org-src-container">
<pre class="src src-racket"><span style="color: #6c6c6c; font-style: italic;">; </span><span style="color: #6c6c6c; font-style: italic;">Note: a macro only takes on argument, which contains the entire syntax object</span>
(<span style="color: #a1db00;">define-syntax</span> (<span style="color: #ffd700;">name</span> stx)
  (<span style="color: #d18aff;">displayln</span> stx))

(name hello world)
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">#&lt;syntax:39:0 (name hello world)&gt;</span>
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">name: received value from syntax expander was not syntax</span>
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">received: #&lt;void&gt;</span>
</pre>
</div>

<p>
We need to add a result that is a syntax object:
</p>

<div class="org-src-container">
<pre class="src src-racket">(<span style="color: #a1db00;">define-syntax</span> (<span style="color: #ffd700;">name</span> stx)
  (<span style="color: #d18aff;">displayln</span> stx)
  #'(<span style="color: #d18aff;">void</span>))

(name hello world)
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">#&lt;syntax:41:0 (name hello world)&gt;</span>
</pre>
</div>

<p>
Now to extract some values. There are primitives used to extract
information from syntax objects.
</p>

<div class="org-src-container">
<pre class="src src-racket">(<span style="color: #a1db00;">define-syntax</span> (<span style="color: #ffd700;">name</span> stx)
  (<span style="color: #d18aff;">displayln</span> `(<span style="color: #ff4ea3;">"stx"</span> ,stx))
  (<span style="color: #d18aff;">displayln</span> `(<span style="color: #ff4ea3;">"syntax-e"</span> ,(<span style="color: #d18aff;">syntax-e</span> stx)))
  (<span style="color: #d18aff;">displayln</span> `(<span style="color: #ff4ea3;">"syntax-&gt;list"</span> ,(<span style="color: #d18aff;">syntax-&gt;list</span> stx)))
  (<span style="color: #d18aff;">displayln</span> `(<span style="color: #ff4ea3;">"syntax-source"</span> ,(<span style="color: #d18aff;">syntax-source</span> stx)))
  (<span style="color: #d18aff;">displayln</span> `(<span style="color: #ff4ea3;">"syntax-line"</span> ,(<span style="color: #d18aff;">syntax-line</span> stx)))
  (<span style="color: #d18aff;">displayln</span> `(<span style="color: #ff4ea3;">"syntax-column"</span> ,(<span style="color: #d18aff;">syntax-column</span> stx)))
  (<span style="color: #d18aff;">displayln</span> `(<span style="color: #ff4ea3;">"syntax-position"</span> ,(<span style="color: #d18aff;">syntax-position</span> stx)))
  (<span style="color: #d18aff;">displayln</span> `(<span style="color: #ff4ea3;">"syntax?"</span> ,(<span style="color: #d18aff;">syntax?</span> stx)))
  (<span style="color: #d18aff;">displayln</span> `(<span style="color: #ff4ea3;">"syntax-span"</span> ,(<span style="color: #d18aff;">syntax-span</span> stx)))
  (<span style="color: #d18aff;">displayln</span> `(<span style="color: #ff4ea3;">"syntax-original?"</span> ,(<span style="color: #d18aff;">syntax-original?</span> stx)))
  (<span style="color: #d18aff;">displayln</span> `(<span style="color: #ff4ea3;">"syntax-source-module"</span> ,(<span style="color: #d18aff;">syntax-source-module</span> stx)))
  (<span style="color: #d18aff;">displayln</span> `(<span style="color: #ff4ea3;">"syntax-&gt;datum"</span> ,(<span style="color: #d18aff;">syntax-&gt;datum</span> stx)))
  #'(<span style="color: #d18aff;">void</span>))

(name hello world)
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">(stx #&lt;syntax:43:0 (name hello world)&gt;)</span>
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">(syntax-e (#&lt;syntax:43:0 name&gt; #&lt;syntax:43:0 hello&gt; #&lt;syntax:43:0 world&gt;))</span>
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">(syntax-&gt;list (#&lt;syntax:43:0 name&gt; #&lt;syntax:43:0 hello&gt; #&lt;syntax:43:0 world&gt;))</span>
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">(syntax-source eval)</span>
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">(syntax-line 43)</span>
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">(syntax-column 0)</span>
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">(syntax-position 43)</span>
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">(syntax? #t)</span>
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">(syntax-span 1)</span>
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">(syntax-original? #f)</span>
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">(syntax-source-module #f)</span>
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">(syntax-&gt;datum (name hello world))</span>
</pre>
</div>

<p>
These are some of the functions that we can use on syntax objects.
There's another one that allows us to turn datums into syntax called
<code>datum-&gt;syntax</code>. Let's see if we can construct a simple macro based on
this and <code>syntax-e</code>:
</p>

<p>
We're gonna make <code>(infix 1 + 2)</code> return <code>(+ 1 2)</code>.
</p>

<div class="org-src-container">
<pre class="src src-racket">(<span style="color: #a1db00;">define-syntax</span> (<span style="color: #ffd700;">infix</span> stx)
  (<span style="color: #a1db00;">let</span> ([<span style="color: #ff8700;">elems</span> (<span style="color: #d18aff;">syntax-e</span> stx)])
    (<span style="color: #a1db00;">when</span> (<span style="color: #d18aff;">not</span> (<span style="color: #d18aff;">=</span> (<span style="color: #d18aff;">length</span> elems) <span style="color: #2e8b57;">4</span>))
      (<span style="color: #d18aff;">raise-syntax-error</span> <span style="color: #ff4ea3;">"there should be 3 elements"</span>))
    (<span style="color: #d18aff;">datum-&gt;syntax</span> stx `(,(<span style="color: #d18aff;">caddr</span> elems) ,(<span style="color: #d18aff;">cadr</span> elems) ,(<span style="color: #d18aff;">cadddr</span> elems)))))

(infix <span style="color: #2e8b57;">1</span> <span style="color: #d18aff;">+</span> <span style="color: #2e8b57;">2</span>)
<span style="color: #6c6c6c; font-style: italic;">; </span><span style="color: #6c6c6c; font-style: italic;">3</span>
</pre>
</div>

<p>
Notice how there are 4 elements in the list, because infix is inside it
too. We also need to provide a context for <code>datum-&gt;syntax</code>. The
identifiers used in the result will be referenced from that context. In
this case we used stx as the context. If you use <code>#f</code>, then <code>+</code> won't be
found and we have an error. The macro is essentially equivalent to:
</p>

<div class="org-src-container">
<pre class="src src-racket">(define-syntax-parser <span style="color: #ff8700;">infix</span>
  [(<span style="color: #a1db00;">_</span> a op b)
   #'(op a b)])

(infix <span style="color: #2e8b57;">1</span> <span style="color: #d18aff;">+</span> <span style="color: #2e8b57;">2</span>)
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">3</span>
</pre>
</div>

<p>
With <code>syntax-parse</code> the context is dependent on the input. This way we can
safely refer to variables from the caller's scope. This safety is what
we call "macro hygiene", and allows us to compose macros without
breaking them.
</p>
</div>
</div>

<div id="outline-container-org0106dc2" class="outline-2">
<h2 id="org0106dc2"><span class="section-number-2">11</span> Syntax parameters, what are they for?</h2>
<div class="outline-text-2" id="text-11">
<dl class="org-dl">
<dt>anaphoric macro</dt><dd>A macro that can define <i>macro-local</i> variables.</dd>
</dl>

<p>
This isn't composable because replacing code with anaphoric macros may
break it, I present you exhibit A, the unhygienic macro:
</p>

<div class="org-src-container">
<pre class="src src-racket">(<span style="color: #a1db00;">define-syntax</span> (<span style="color: #ffd700;">aif</span> stx)
  (<span style="color: #a1db00;">let</span> ([<span style="color: #ff8700;">elems</span> (<span style="color: #d18aff;">syntax-e</span> stx)])
    (<span style="color: #d18aff;">datum-&gt;syntax</span> stx
                   `(<span style="color: #a1db00;">let</span> ([<span style="color: #ff8700;">it</span> ,(<span style="color: #d18aff;">cadr</span> elems)])
                      (<span style="color: #a1db00;">if</span> it ,(<span style="color: #d18aff;">caddr</span> elems) ,(<span style="color: #d18aff;">cadddr</span> elems))))))

(<span style="color: #a1db00;">define</span> <span style="color: #ff8700;">it</span> <span style="color: #2e8b57;">10</span>)
(aif (<span style="color: #d18aff;">member</span> <span style="color: #2e8b57;">2</span> '(<span style="color: #2e8b57;">1</span> <span style="color: #2e8b57;">2</span> <span style="color: #2e8b57;">3</span>))
     (<span style="color: #d18aff;">displayln</span> it)
     (<span style="color: #d18aff;">void</span>))
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">(2 3)</span>
</pre>
</div>

<p>
The programmer wanted to print 10 but instead something else got
printed. This is a trivial example but quickly balloons with bigger
programs and bigger macros.
</p>

<p>
Let's instead use <code>syntax-parameters</code>. These can be used hygienically:
</p>

<div class="org-src-container">
<pre class="src src-racket">(<span style="color: #a1db00;">require</span> racket/stxparam)

(define-syntax-parameter <span style="color: #ff8700;">it</span> (<span style="color: #d18aff;">syntax-parser</span>))

(define-syntax-parser <span style="color: #ff8700;">aif</span>
  [(<span style="color: #a1db00;">_</span> condition then otherwise)
   #'(<span style="color: #a1db00;">let</span> ([<span style="color: #ff8700;">t</span> condition])
       (syntax-parameterize ([it (<span style="color: #d18aff;">syntax-parser</span> [<span style="color: #a1db00;">_</span> #<span style="color: #2e8b57;">'t</span>])])
         (<span style="color: #a1db00;">if</span> t then otherwise)))])

(aif (<span style="color: #d18aff;">member</span> <span style="color: #2e8b57;">2</span> '(<span style="color: #2e8b57;">1</span> <span style="color: #2e8b57;">2</span> <span style="color: #2e8b57;">3</span>))
     (<span style="color: #d18aff;">displayln</span> it)
     (<span style="color: #d18aff;">void</span>))
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">(2 3)</span>
</pre>
</div>

<p>
If we now have a declaration of it, that will override the syntax
parameter.
</p>

<div class="org-src-container">
<pre class="src src-racket">(<span style="color: #a1db00;">let</span> ([<span style="color: #ff8700;">it</span> <span style="color: #2e8b57;">10</span>])
  (aif (<span style="color: #d18aff;">member</span> <span style="color: #2e8b57;">2</span> '(<span style="color: #2e8b57;">1</span> <span style="color: #2e8b57;">2</span> <span style="color: #2e8b57;">3</span>))
       (<span style="color: #d18aff;">displayln</span> it)
       (<span style="color: #d18aff;">void</span>)))
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">10</span>
</pre>
</div>

<p>
During normal racket evaluation (i.e. from a file) you'll get a
<code>duplicate-identifier</code> error, in this context there's another error, but
the point is that there is an error instead of letting the programmer
scratch his head.
</p>

<div class="org-src-container">
<pre class="src src-racket">(<span style="color: #a1db00;">define</span> <span style="color: #ff8700;">it</span> <span style="color: #2e8b57;">10</span>)
(aif (<span style="color: #d18aff;">member</span> <span style="color: #2e8b57;">2</span> '(<span style="color: #2e8b57;">1</span> <span style="color: #2e8b57;">2</span> <span style="color: #2e8b57;">3</span>))
     (<span style="color: #d18aff;">displayln</span> it)
     (<span style="color: #d18aff;">void</span>))
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">eval:53:0: syntax-parameterize: not bound as a syntax</span>
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">parameter</span>
<span style="color: #6c6c6c; font-style: italic;">;;   </span><span style="color: #6c6c6c; font-style: italic;">at: it</span>
<span style="color: #6c6c6c; font-style: italic;">;;   </span><span style="color: #6c6c6c; font-style: italic;">in: (syntax-parameterize ((it (syntax-parser (_ (syntax</span>
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">t))))) (if t (displayln it) (void)))</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org0ac2090" class="outline-2">
<h2 id="org0ac2090"><span class="section-number-2">12</span> I don't get it, how does <code>syntax-parse</code> work?</h2>
<div class="outline-text-2" id="text-12">
<p>
<code>syntax-parse</code> works by <b>replacing</b> <span class="underline">all syntax objects after the pattern
match</span> with the results from the pattern match:
</p>

<div class="org-src-container">
<pre class="src src-racket">(<span style="color: #d18aff;">syntax-parse</span> #'(<span style="color: #d18aff;">this</span> is some <span style="color: #a1db00;">syntax</span>)
  [(here is the pattern) #'(pattern is put here)])
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">#&lt;syntax:58:0 (syntax is put this)&gt;</span>
</pre>
</div>

<p>
<code>put</code> is <span class="underline"><b>not</b> in the pattern</span>, so it's just pasted <i>as-is</i>.
</p>
</div>

<div id="outline-container-orgb93d74b" class="outline-3">
<h3 id="orgb93d74b"><span class="section-number-3">12.1</span> Another cool thing: you can run arbitrary code in the body:</h3>
<div class="outline-text-3" id="text-12-1">
<div class="org-src-container">
<pre class="src src-racket">(<span style="color: #d18aff;">syntax-parse</span> #'(<span style="color: #d18aff;">this</span> is some <span style="color: #a1db00;">syntax</span>)
  [(here is the pattern)
   (<span style="color: #d18aff;">displayln</span> <span style="color: #ff4ea3;">"This is arbitrary code, we could download webpages for use in this macro, whatever you wish"</span>)
   #'(pattern is put here)])

<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">This is arbitrary code, we could download webpages for use in this macro, whatever you wish</span>
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">#&lt;syntax:59:0 (syntax is put this)&gt;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org9ac2571" class="outline-3">
<h3 id="org9ac2571"><span class="section-number-3">12.2</span> There are also some special pattern forms:</h3>
<div class="outline-text-3" id="text-12-2">
<div class="org-src-container">
<pre class="src src-racket">(<span style="color: #d18aff;">syntax-parse</span> #'(<span style="color: #d18aff;">this</span> is some <span style="color: #a1db00;">syntax</span>)
  [(here <span style="color: #a1db00;">...</span>) #'(here <span style="color: #a1db00;">...</span> put stuff)])
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">#&lt;syntax:60:0 (this is some syntax put stuff)&gt;</span>
</pre>
</div>
</div>

<div id="outline-container-org9d00f51" class="outline-4">
<h4 id="org9d00f51"><span class="section-number-4">12.2.1</span> Table of forms</h4>
<div class="outline-text-4" id="text-12-2-1">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">syntax</th>
<th scope="col" class="org-left">description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>...</code></td>
<td class="org-left">a postfix operator that makes <code>syntax-parse</code> consider whatever is before as a list of that pattern. It will expand this list in the expander when it is encountered. This allows us to create pretty complex macros</td>
</tr>

<tr>
<td class="org-left"><code>...+</code></td>
<td class="org-left">means one or more.</td>
</tr>
</tbody>
</table>

<div class="org-src-container">
<pre class="src src-racket">(<span style="color: #d18aff;">syntax-parse</span> #'((<span style="color: #d18aff;">this</span> is) (some <span style="color: #a1db00;">syntax</span>))
  [((here there) ...+) #'(here <span style="color: #a1db00;">...</span> there <span style="color: #a1db00;">...</span> put stuff)])
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">#&lt;syntax:61:0 (this some is syntax put stuff)&gt;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org3e85d3c" class="outline-4">
<h4 id="org3e85d3c"><span class="section-number-4">12.2.2</span> They can even be nested</h4>
<div class="outline-text-4" id="text-12-2-2">
<div class="org-src-container">
<pre class="src src-racket">(<span style="color: #d18aff;">syntax-parse</span> #'((<span style="color: #d18aff;">this</span> is) (some more stuff <span style="color: #a1db00;">syntax</span>))
  [((here <span style="color: #a1db00;">...</span> there) ...+) #'(here <span style="color: #a1db00;">...</span> <span style="color: #a1db00;">...</span> there <span style="color: #a1db00;">...</span> put stuff)])
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">#&lt;syntax:62:0 (this some more stuff is synt...&gt;</span>
</pre>
</div>

<p>
Note that the <code>...</code> operator in the syntax has left-associativity, so:
</p>
<ul class="org-ul">
<li><code>here ... ...</code> <i>reduces to</i> (in this case) <code>((this) (some more stuff)) ...  ...</code></li>
<li>which <i>reduces to</i> <code>(this) ... (some more stuff) ...</code></li>
<li>which <i>reduces to</i> <code>this some more stuff</code></li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-orgedb47ef" class="outline-2">
<h2 id="orgedb47ef"><span class="section-number-2">13</span> Read the original article <a href="https://kevin.stravers.net/2017/11/practical-macros-in-racket-and-how-to-work-with-them.html"><span class="underline">here</span></a>.</h2>
</div>

<div id="outline-container-org2cb1be4" class="outline-2">
<h2 id="org2cb1be4"><span class="section-number-2">14</span> Take-away notes</h2>
<div class="outline-text-2" id="text-14">
</div>
<div id="outline-container-orgd4a360e" class="outline-3">
<h3 id="orgd4a360e"><span class="section-number-3">14.1</span> parts of syntax</h3>
<div class="outline-text-3" id="text-14-1">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">syntax</th>
<th scope="col" class="org-left">description</th>
<th scope="col" class="org-left">family</th>
<th scope="col" class="org-left">use</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>#with</code></td>
<td class="org-left">&#xa0;</td>
<td class="org-left"><code>syntax-parse</code></td>
<td class="org-left"></td>
</tr>

<tr>
<td class="org-left"><code>with-syntax</code></td>
<td class="org-left">&#xa0;</td>
<td class="org-left"><code>syntax-case</code></td>
<td class="org-left"></td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orga050531" class="outline-3">
<h3 id="orga050531"><span class="section-number-3">14.2</span> syntax transformer families</h3>
<div class="outline-text-3" id="text-14-2">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">family</th>
<th scope="col" class="org-left">description</th>
<th scope="col" class="org-left">use</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>syntax-parse</code></td>
<td class="org-left">the most advanced</td>
<td class="org-left"></td>
</tr>

<tr>
<td class="org-left"><code>syntax-case</code></td>
<td class="org-left">the typeless version of syntax-parse</td>
<td class="org-left"></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2017-11-17 Fri 00:00</p>
<p class="author">Author: Kevin R. Stravers</p>
<p class="date">Created: 2018-10-14 Sun 22:08</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>