<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2018-10-14 Sun 18:48 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Practical macros in Racket and how to work with them</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Kevin R. Stravers" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="org-main.css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Practical macros in Racket and how to work with them</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgd486a1a">1. Read the original article here.</a></li>
<li><a href="#org140a703">2. Practical macros in Racket and how to work with them</a></li>
<li><a href="#orga3c939b">3. What's all this racket?</a></li>
<li><a href="#org4c8a884">4. <code>syntax-case</code>, don't use it!</a></li>
<li><a href="#orga6f9667">5. <code>with-syntax</code></a></li>
<li><a href="#orgfd0c9d6">6. The <code>syntax-parse</code> family</a></li>
<li><a href="#orge6f06e7">7. <code>make-rename-transformer</code></a></li>
<li><a href="#org6ec6057">8. <code>make-set!-transformer</code></a></li>
<li><a href="#orgd1f46f4">9. Syntax taints, what are they?</a></li>
<li><a href="#org59eb649">10. Literals</a></li>
<li><a href="#org4c20261">11. Experimenting with the lowest level</a></li>
<li><a href="#org5827971">12. Syntax parameters, what are they for?</a></li>
<li><a href="#org313156d">13. I don't get it, how does <code>syntax-parse</code> work?</a></li>
<li><a href="#org918dfd1">14. Read the original article here.</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgd486a1a" class="outline-2">
<h2 id="orgd486a1a"><span class="section-number-2">1</span> Read the original article <a href="https://kevin.stravers.net/2017/11/practical-macros-in-racket-and-how-to-work-with-them.html">here</a>.</h2>
</div>

<div id="outline-container-org140a703" class="outline-2">
<h2 id="org140a703"><span class="section-number-2">2</span> Practical macros in Racket and how to work with them</h2>
<div class="outline-text-2" id="text-2">
<p>
A macro is central in any Lisp and must be mastered in order to master
the language. However, Racket is in a state of macro chaos - at least in
the official documentation. There's <code>define-syntax-rule</code>, <code>syntax-parse</code>,
<code>syntax-case</code>, and so many more. How do we make sense of it? In this
tutorial we'll investigate syntax transformers in Racket so we can get a
complete picture.
</p>
</div>
</div>

<div id="outline-container-orga3c939b" class="outline-2">
<h2 id="orga3c939b"><span class="section-number-2">3</span> What's all this racket?</h2>
<div class="outline-text-2" id="text-3">
<p>
I've looked through the racket documentation and connected most of the
syntax transformers there. Here are the biggest ones and some utility
functions.
</p>


<div class="figure">
<p><img src="macro-graph.png" alt="macro-graph.png" />
</p>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">symbol</th>
<th scope="col" class="org-left">meaning</th>
<th scope="col" class="org-left">example</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Arrows</td>
<td class="org-left">Denote that one can be defined in terms of the other</td>
<td class="org-left"><code>define-simple-macro</code> can be defined in terms of <code>define-syntax-parser</code>.</td>
</tr>

<tr>
<td class="org-left">Dashed boxes</td>
<td class="org-left">Unimportant tools that ought to be deprecated.</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Red boxes</td>
<td class="org-left">Indicate what I believe to be important tools</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">circles</td>
<td class="org-left">Denote important syntax primitives.</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Bold boxes</td>
<td class="org-left">Important but not essential.</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Normal boxes</td>
<td class="org-left">Not that important, but good to know.</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
For the new macro programmer this is quite a lot to take in, and there's
a myriad of other tools that supplement these, but I can safely say that
you can ignore everything except <code>define-syntax-parser</code> if you're new.
Why? Because it's a typechecking syntax transformer and allows you to
manipulate syntax in a complex manner. It also prevents you from having
to use <code>define-syntax</code> together with <code>syntax-parse</code>. In essence it's a way
to define macros in a clean manner.
</p>
</div>
</div>

<div id="outline-container-org4c8a884" class="outline-2">
<h2 id="org4c8a884"><span class="section-number-2">4</span> <code>syntax-case</code>, don't use it!</h2>
<div class="outline-text-2" id="text-4">
<p>
Why not use <code>syntax-case</code>? It appears to be an important primitive. Well
to put it clearly: <code>syntax-case</code> is the <b>typeless</b> version of
<code>syntax-parse</code>.There are some other differences in how arguments are
applied and errors are reported, but what's in bold is the most
important aspect. With <code>syntax-parse</code> we can assert that a term is an
identifier or a keyword in a declarative manner whereas with <code>syntax-case</code>
we'd have to write code that checks types during <code>macro-time</code>.
<code>syntax-parse</code> is widely superior to <code>syntax-case</code>.
</p>

<p>
We should ideally deprecate <code>syntax-case</code> for <code>end-user</code> usage.
</p>
</div>
</div>

<div id="outline-container-orga6f9667" class="outline-2">
<h2 id="orga6f9667"><span class="section-number-2">5</span> <code>with-syntax</code></h2>
<div class="outline-text-2" id="text-5">
<p>
<code>with-syntax</code> is incredibly useful in <code>syntax-case</code> but inside <code>syntax-parse</code>
we should use <code>#:with</code> instead:
</p>

<p>
Examples:
</p>

<div class="org-src-container">
<pre class="src src-racket" id="org75596be">(<span style="color: #a1db00;">require</span> syntax/parse/define)

(define-syntax-parser <span style="color: #ff8700;">with-example</span>
  [(\<span style="color: #a1db00;">_</span> a)
   <span style="color: #cd5c5c;">#:with</span> (b:id <span style="color: #a1db00;">...</span>) #'(one two three)
   #'(<span style="color: #d18aff;">list</span> a <span style="color: #2e8b57;">'b</span> <span style="color: #a1db00;">...</span>)])

(with-example <span style="color: #2e8b57;">'zero</span>)
<span style="color: #6c6c6c; font-style: italic;">; </span><span style="color: #6c6c6c; font-style: italic;">'(zero one two three)</span>
</pre>
</div>

<p>
The advantage of <code>#:with</code> over <code>with-syntax</code> is the use of types and better
error reporting for <code>syntax-parse</code>.
</p>

<p>
For reference, here's <code>with-syntax</code>:
</p>

<div class="org-src-container">
<pre class="src src-racket">(<span style="color: #a1db00;">require</span> syntax/parse/define)

(define-syntax-parser <span style="color: #ff8700;">with-example</span>
  [(\<span style="color: #a1db00;">_</span> a)
   (<span style="color: #a1db00;">with-syntax</span> ([(b <span style="color: #a1db00;">...</span>) #'(one two three)])
     #'(<span style="color: #d18aff;">list</span> a <span style="color: #2e8b57;">'b</span> <span style="color: #a1db00;">...</span>))])

(with-example <span style="color: #2e8b57;">'zero</span>)
<span style="color: #6c6c6c; font-style: italic;">; </span><span style="color: #6c6c6c; font-style: italic;">'(zero one two three)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgfd0c9d6" class="outline-2">
<h2 id="orgfd0c9d6"><span class="section-number-2">6</span> The <code>syntax-parse</code> family</h2>
<div class="outline-text-2" id="text-6">
<p>
<code>syntax-parse</code> is the primitive of the most advanced syntax transformer in
racket (as far as I know). Here are some examples.
</p>

<div class="org-src-container">
<pre class="src src-racket">(<span style="color: #a1db00;">require</span> syntax/parse syntax/parse/define)

(define-syntax-parser <span style="color: #ff8700;">name</span>
  [(\<span style="color: #a1db00;">_</span> a b ...+)
   #'(<span style="color: #d18aff;">+</span> a (<span style="color: #d18aff;">-</span> b <span style="color: #a1db00;">...</span>))])

(name <span style="color: #2e8b57;">1</span> <span style="color: #2e8b57;">2</span> <span style="color: #2e8b57;">3</span> <span style="color: #2e8b57;">4</span>)
<span style="color: #6c6c6c; font-style: italic;">; </span><span style="color: #6c6c6c; font-style: italic;">-4</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-racket">(<span style="color: #a1db00;">define-syntax</span> <span style="color: #ff8700;">name</span>
  (<span style="color: #d18aff;">syntax-parser</span>
    [(\<span style="color: #a1db00;">_</span> a b ...+)
     #'(<span style="color: #d18aff;">+</span> a (<span style="color: #d18aff;">-</span> b <span style="color: #a1db00;">...</span>))]))

(name <span style="color: #2e8b57;">1</span> <span style="color: #2e8b57;">2</span> <span style="color: #2e8b57;">3</span> <span style="color: #2e8b57;">4</span>)
<span style="color: #6c6c6c; font-style: italic;">; </span><span style="color: #6c6c6c; font-style: italic;">-4</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-racket">(<span style="color: #a1db00;">define-syntax</span> (<span style="color: #ffd700;">name</span> stx)
  (<span style="color: #d18aff;">syntax-parse</span> stx
    [(\<span style="color: #a1db00;">_</span> a b ...+)
     #'(<span style="color: #d18aff;">+</span> a (<span style="color: #d18aff;">-</span> b <span style="color: #a1db00;">...</span>))]))

(name <span style="color: #2e8b57;">1</span> <span style="color: #2e8b57;">2</span> <span style="color: #2e8b57;">3</span> <span style="color: #2e8b57;">4</span>)
<span style="color: #6c6c6c; font-style: italic;">; </span><span style="color: #6c6c6c; font-style: italic;">-4</span>
</pre>
</div>

<p>
These forms are all acceptable depending on your situation. Most of the
time we want to use <code>define-syntax-parser</code> because it saves us the effort
of typing so much.
</p>
</div>
</div>

<div id="outline-container-orge6f06e7" class="outline-2">
<h2 id="orge6f06e7"><span class="section-number-2">7</span> <code>make-rename-transformer</code></h2>
<div class="outline-text-2" id="text-7">
<p>
This special transformer is basically an alias that preserves identifier
equality.
</p>

<div class="org-src-container">
<pre class="src src-racket">(<span style="color: #a1db00;">define-syntax</span> <span style="color: #ff8700;">l</span> (<span style="color: #d18aff;">make-rename-transformer</span> #<span style="color: #2e8b57;">'let</span>))
(<span style="color: #a1db00;">let</span> ([<span style="color: #ff8700;">a</span> <span style="color: #2e8b57;">1</span>] [<span style="color: #ff8700;">b</span> <span style="color: #2e8b57;">2</span>]) (<span style="color: #d18aff;">+</span> a b))
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">3</span>

(l ([a <span style="color: #2e8b57;">1</span>] [b <span style="color: #2e8b57;">2</span>]) (<span style="color: #d18aff;">+</span> a b))
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">3</span>

(<span style="color: #d18aff;">free-identifier=?</span> #<span style="color: #2e8b57;">'let</span> #<span style="color: #2e8b57;">'l</span>)
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">#t</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org6ec6057" class="outline-2">
<h2 id="org6ec6057"><span class="section-number-2">8</span> <code>make-set!-transformer</code></h2>
<div class="outline-text-2" id="text-8">
<p>
Another special transformer is the <code>set!-transformer</code>, it allows you to
transform a mutation of an identifier.
</p>

<div class="org-src-container">
<pre class="src src-racket">(<span style="color: #a1db00;">define</span> <span style="color: #ff8700;">a</span> <span style="color: #2e8b57;">0</span>)
(<span style="color: #a1db00;">define</span> <span style="color: #ff8700;">b</span> <span style="color: #2e8b57;">1</span>)

(<span style="color: #a1db00;">let-syntax</span> ([<span style="color: #ff8700;">a</span> (<span style="color: #d18aff;">make-set!-transformer</span>
                 (<span style="color: #d18aff;">syntax-parser</span> <span style="color: #cd5c5c;">#:literals</span> (<span style="color: #a1db00;">set!</span>)
                                [(<span style="color: #a1db00;">set!</span> \<span style="color: #a1db00;">_</span> v) #'(<span style="color: #a1db00;">set!</span> b v)]
                                [i:id #<span style="color: #2e8b57;">'a</span>]))])
  (<span style="color: #a1db00;">set!</span> a <span style="color: #2e8b57;">2</span>)
  (<span style="color: #d18aff;">list</span> a b))

<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">'(0 2)</span>
</pre>
</div>

<p>
I haven't had much use for this in my code so far, but I guess it's fine
to keep in mind in case you need it.
</p>
</div>
</div>

<div id="outline-container-orgd1f46f4" class="outline-2">
<h2 id="orgd1f46f4"><span class="section-number-2">9</span> Syntax taints, what are they?</h2>
<div class="outline-text-2" id="text-9">
<p>
The documentation on syntax taints is confusing to me. Here's my
synopsis: It prevents the arbitrary use of identifiers: if you extract
any part of another macro's armed result, then that extracted part is
tainted and can't be used further. Allow me to exemplify:
</p>

<p>
Examples:
</p>

<div class="org-src-container">
<pre class="src src-racket">(<span style="color: #a1db00;">require</span> syntax/parse/define)

(define-syntax-parser <span style="color: #ff8700;">a</span>
  [(\<span style="color: #a1db00;">_</span>) (<span style="color: #d18aff;">syntax-protect</span> #'(c))])
<span style="color: #6c6c6c; font-style: italic;">; </span><span style="color: #6c6c6c; font-style: italic;">(c) is armed here</span>

(define-syntax-parser <span style="color: #ff8700;">b</span>
  [(\<span style="color: #a1db00;">_</span>)
   <span style="color: #6c6c6c; font-style: italic;">; </span><span style="color: #6c6c6c; font-style: italic;">c is extracted from (c), which taints the result c</span>
   <span style="color: #cd5c5c;">#:with</span> d (<span style="color: #d18aff;">car</span> (<span style="color: #d18aff;">syntax-e</span> (<span style="color: #d18aff;">local-expand</span> #'(a) <span style="color: #2e8b57;">'expression</span> <span style="color: #2e8b57;">#f</span>)))
   <span style="color: #6c6c6c; font-style: italic;">; </span><span style="color: #6c6c6c; font-style: italic;">the macro expander inserts d which results in #'(+ TAINTED:c), so the expander rejects this</span>
   #'(<span style="color: #d18aff;">+</span> d)])

(b)
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">eval:22:0: #%top: cannot use identifier tainted by macro</span>
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">transformation</span>
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">in: #%top</span>
</pre>
</div>

<p>
This rejects the expression <code>(+ c)</code> because the identifier <code>c</code> is <b>tainted</b>.
Why is it tainted? Because <code>syntax-e</code> tainted it. Why did it taint it?
Because the <code>syntax-object</code> was <b>armed</b>.
</p>

<div class="org-src-container">
<pre class="src src-racket">(<span style="color: #a1db00;">require</span> syntax/parse/define)
(<span style="color: #a1db00;">define</span> <span style="color: #ff8700;">c</span> <span style="color: #2e8b57;">10</span>)

(define-syntax-parser <span style="color: #ff8700;">a</span>
  [(\<span style="color: #a1db00;">_</span>) (<span style="color: #d18aff;">syntax-protect</span> #<span style="color: #2e8b57;">'c</span>)])

(define-syntax-parser <span style="color: #ff8700;">b</span>
  [(\<span style="color: #a1db00;">_</span>)
   <span style="color: #cd5c5c;">#:with</span> d #'(a)
   #'(<span style="color: #d18aff;">displayln</span> d)])

(b)
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">10</span>
</pre>
</div>

<p>
This shows that the expander
</p>
<ul class="org-ul">
<li>accepts
<ul class="org-ul">
<li><i>armed</i>, and</li>
<li><i>clean</i> syntax objects, but</li>
</ul></li>
<li>rejects
<ul class="org-ul">
<li><i>tainted</i> syntax objects.</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org59eb649" class="outline-2">
<h2 id="org59eb649"><span class="section-number-2">10</span> Literals</h2>
<div class="outline-text-2" id="text-10">
<p>
<code>syntax-parse</code> allows the use of literals:
</p>

<div class="org-src-container">
<pre class="src src-racket">(<span style="color: #a1db00;">require</span> syntax/parse/define)

(define-syntax-parser <span style="color: #ff8700;">my-parser</span>
  <span style="color: #cd5c5c;">#:datum-literals</span> (a-word)
  [(\<span style="color: #a1db00;">_</span> a-word b-word)
   #'(<span style="color: #a1db00;">begin</span>
       (<span style="color: #d18aff;">displayln</span> <span style="color: #2e8b57;">'a-word</span>)
       (<span style="color: #d18aff;">displayln</span> <span style="color: #2e8b57;">'b-word</span>))])

(my-parser a-word <span style="color: #2e8b57;">10</span>)

a-word
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">10</span>
</pre>
</div>

<p>
<code>#:literals</code> is also possible. Then there's a need for an identifier to
exist in the enclosing phase:
</p>

<div class="org-src-container">
<pre class="src src-racket">(define-syntax-parser <span style="color: #ff8700;">my-parser</span>
  <span style="color: #cd5c5c;">#:literals</span> (is-this-bound?)
  [(\<span style="color: #a1db00;">_</span> is-this-bound? b-word)
   #'(<span style="color: #a1db00;">begin</span>
       (<span style="color: #d18aff;">displayln</span> <span style="color: #2e8b57;">'a-word</span>)
       (<span style="color: #d18aff;">displayln</span> <span style="color: #2e8b57;">'b-word</span>))])

(my-parser is-this-bound? <span style="color: #2e8b57;">10</span>)
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">eval:33:0: syntax-parser: literal is unbound in phase 0</span>
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">(phase 0 relative to the enclosing module)</span>
<span style="color: #6c6c6c; font-style: italic;">;;   </span><span style="color: #6c6c6c; font-style: italic;">at: is-this-bound?</span>
<span style="color: #6c6c6c; font-style: italic;">;;   </span><span style="color: #6c6c6c; font-style: italic;">in: (syntax-parser #:literals (is-this-bound?) ((\_</span>
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">is-this-bound? b-word) (syntax (begin (displayln (quote</span>
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">a-word)) (displayln (quote b-word))))))</span>
</pre>
</div>

<p>
We can use literals to discriminate between real and fake identifiers:
</p>

<div class="org-src-container">
<pre class="src src-racket">(define-syntax-parser <span style="color: #ff8700;">is-it-let?</span>
  [(\<span style="color: #a1db00;">_</span> (~literal <span style="color: #a1db00;">let</span>)) #<span style="color: #2e8b57;">'#t</span>]
  [(\<span style="color: #a1db00;">_</span> (~datum <span style="color: #a1db00;">let</span>)) #<span style="color: #2e8b57;">'#f</span>]
  [\<span style="color: #a1db00;">_</span> #<span style="color: #2e8b57;">'#f</span>])

(is-it-let? <span style="color: #a1db00;">let</span>)
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">#t</span>

(<span style="color: #a1db00;">let</span> ([<span style="color: #ff8700;">let</span> <span style="color: #2e8b57;">0</span>])
  (is-it-let? <span style="color: #a1db00;">let</span>))
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">#f</span>
</pre>
</div>

<p>
Note that <code>(~literal x)</code> as a pattern is the same as specifying <code>#:literals
(x)</code> as keyword argument and using x as a pattern. Similarly for
<code>#:datum-literals (x)</code>.
</p>
</div>
</div>

<div id="outline-container-org4c20261" class="outline-2">
<h2 id="org4c20261"><span class="section-number-2">11</span> Experimenting with the lowest level</h2>
<div class="outline-text-2" id="text-11">
<p>
Using <code>define-syntax</code> we can define simple functions that are essentially
macros that don't pattern match. This style allows you to get to know
the low-level API, and I believe it to be very important to experiment
with to understand what <code>syntax-parse</code> is actually doing.
</p>

<p>
Vision is the most important thing, let's look at what's going on!
</p>

<div class="org-src-container">
<pre class="src src-racket"><span style="color: #6c6c6c; font-style: italic;">; </span><span style="color: #6c6c6c; font-style: italic;">Note: a macro only takes on argument, which contains the entire syntax object</span>
(<span style="color: #a1db00;">define-syntax</span> (<span style="color: #ffd700;">name</span> stx)
  (<span style="color: #d18aff;">displayln</span> stx))

(name hello world)
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">#&lt;syntax:39:0 (name hello world)&gt;</span>
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">name: received value from syntax expander was not syntax</span>
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">received: #&lt;void&gt;</span>
</pre>
</div>

<p>
We need to add a result that is a syntax object:
</p>

<div class="org-src-container">
<pre class="src src-racket">(<span style="color: #a1db00;">define-syntax</span> (<span style="color: #ffd700;">name</span> stx)
  (<span style="color: #d18aff;">displayln</span> stx)
  #'(<span style="color: #d18aff;">void</span>))

(name hello world)
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">#&lt;syntax:41:0 (name hello world)&gt;</span>
</pre>
</div>

<p>
Now to extract some values. There are primitives used to extract
information from syntax objects.
</p>

<div class="org-src-container">
<pre class="src src-racket">(<span style="color: #a1db00;">define-syntax</span> (<span style="color: #ffd700;">name</span> stx)
  (<span style="color: #d18aff;">displayln</span> `(<span style="color: #ff4ea3;">"stx"</span> ,stx))
  (<span style="color: #d18aff;">displayln</span> `(<span style="color: #ff4ea3;">"syntax-e"</span> ,(<span style="color: #d18aff;">syntax-e</span> stx)))
  (<span style="color: #d18aff;">displayln</span> `(<span style="color: #ff4ea3;">"syntax-&gt;list"</span> ,(<span style="color: #d18aff;">syntax-&gt;list</span> stx)))
  (<span style="color: #d18aff;">displayln</span> `(<span style="color: #ff4ea3;">"syntax-source"</span> ,(<span style="color: #d18aff;">syntax-source</span> stx)))
  (<span style="color: #d18aff;">displayln</span> `(<span style="color: #ff4ea3;">"syntax-line"</span> ,(<span style="color: #d18aff;">syntax-line</span> stx)))
  (<span style="color: #d18aff;">displayln</span> `(<span style="color: #ff4ea3;">"syntax-column"</span> ,(<span style="color: #d18aff;">syntax-column</span> stx)))
  (<span style="color: #d18aff;">displayln</span> `(<span style="color: #ff4ea3;">"syntax-position"</span> ,(<span style="color: #d18aff;">syntax-position</span> stx)))
  (<span style="color: #d18aff;">displayln</span> `(<span style="color: #ff4ea3;">"syntax?"</span> ,(<span style="color: #d18aff;">syntax?</span> stx)))
  (<span style="color: #d18aff;">displayln</span> `(<span style="color: #ff4ea3;">"syntax-span"</span> ,(<span style="color: #d18aff;">syntax-span</span> stx)))
  (<span style="color: #d18aff;">displayln</span> `(<span style="color: #ff4ea3;">"syntax-original?"</span> ,(<span style="color: #d18aff;">syntax-original?</span> stx)))
  (<span style="color: #d18aff;">displayln</span> `(<span style="color: #ff4ea3;">"syntax-source-module"</span> ,(<span style="color: #d18aff;">syntax-source-module</span> stx)))
  (<span style="color: #d18aff;">displayln</span> `(<span style="color: #ff4ea3;">"syntax-&gt;datum"</span> ,(<span style="color: #d18aff;">syntax-&gt;datum</span> stx)))
  #'(<span style="color: #d18aff;">void</span>))

(name hello world)
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">(stx #&lt;syntax:43:0 (name hello world)&gt;)</span>
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">(syntax-e (#&lt;syntax:43:0 name&gt; #&lt;syntax:43:0 hello&gt; #&lt;syntax:43:0 world&gt;))</span>
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">(syntax-&gt;list (#&lt;syntax:43:0 name&gt; #&lt;syntax:43:0 hello&gt; #&lt;syntax:43:0 world&gt;))</span>
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">(syntax-source eval)</span>
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">(syntax-line 43)</span>
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">(syntax-column 0)</span>
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">(syntax-position 43)</span>
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">(syntax? #t)</span>
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">(syntax-span 1)</span>
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">(syntax-original? #f)</span>
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">(syntax-source-module #f)</span>
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">(syntax-&gt;datum (name hello world))</span>
</pre>
</div>

<p>
These are some of the functions that we can use on syntax objects.
There's another one that allows us to turn datums into syntax called
<code>datum-&gt;syntax</code>. Let's see if we can construct a simple macro based on
this and <code>syntax-e</code>:
</p>

<p>
We're gonna make <code>(infix 1 + 2)</code> return <code>(+ 1 2)</code>.
</p>

<div class="org-src-container">
<pre class="src src-racket">(<span style="color: #a1db00;">define-syntax</span> (<span style="color: #ffd700;">infix</span> stx)
  (<span style="color: #a1db00;">let</span> ([<span style="color: #ff8700;">elems</span> (<span style="color: #d18aff;">syntax-e</span> stx)])
    (<span style="color: #a1db00;">when</span> (<span style="color: #d18aff;">not</span> (<span style="color: #d18aff;">=</span> (<span style="color: #d18aff;">length</span> elems) <span style="color: #2e8b57;">4</span>))
      (<span style="color: #d18aff;">raise-syntax-error</span> <span style="color: #ff4ea3;">"there should be 3 elements"</span>))
    (<span style="color: #d18aff;">datum-&gt;syntax</span> stx `(,(<span style="color: #d18aff;">caddr</span> elems) ,(<span style="color: #d18aff;">cadr</span> elems) ,(<span style="color: #d18aff;">cadddr</span> elems)))))

(infix <span style="color: #2e8b57;">1</span> <span style="color: #d18aff;">+</span> <span style="color: #2e8b57;">2</span>)
<span style="color: #6c6c6c; font-style: italic;">; </span><span style="color: #6c6c6c; font-style: italic;">3</span>
</pre>
</div>

<p>
Notice how there are 4 elements in the list, because infix is inside it
too. We also need to provide a context for <code>datum-&gt;syntax</code>. The
identifiers used in the result will be referenced from that context. In
this case we used stx as the context. If you use <code>#f</code>, then <code>+</code> won't be
found and we have an error. The macro is essentially equivalent to:
</p>

<div class="org-src-container">
<pre class="src src-racket">(define-syntax-parser <span style="color: #ff8700;">infix</span>
  [(\<span style="color: #a1db00;">_</span> a op b)
   #'(op a b)])

(infix <span style="color: #2e8b57;">1</span> <span style="color: #d18aff;">+</span> <span style="color: #2e8b57;">2</span>)
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">3</span>
</pre>
</div>

<p>
With <code>syntax-parse</code> the context is dependent on the input. This way we can
safely refer to variables from the caller's scope. This safety is what
we call "macro hygiene", and allows us to compose macros without
breaking them.
</p>
</div>
</div>

<div id="outline-container-org5827971" class="outline-2">
<h2 id="org5827971"><span class="section-number-2">12</span> Syntax parameters, what are they for?</h2>
<div class="outline-text-2" id="text-12">
<p>
An anaphoric macro is a macro that can define macro-local variables.
This isn't composable because replacing code with anaphoric macros may
break it, I present you exhibit A, the unhygienic macro:
</p>

<div class="org-src-container">
<pre class="src src-racket">(<span style="color: #a1db00;">define-syntax</span> (<span style="color: #ffd700;">aif</span> stx)
  (<span style="color: #a1db00;">let</span> ([<span style="color: #ff8700;">elems</span> (<span style="color: #d18aff;">syntax-e</span> stx)])
    (<span style="color: #d18aff;">datum-&gt;syntax</span> stx
                   `(<span style="color: #a1db00;">let</span> ([<span style="color: #ff8700;">it</span> ,(<span style="color: #d18aff;">cadr</span> elems)])
                      (<span style="color: #a1db00;">if</span> it ,(<span style="color: #d18aff;">caddr</span> elems) ,(<span style="color: #d18aff;">cadddr</span> elems))))))

(<span style="color: #a1db00;">define</span> <span style="color: #ff8700;">it</span> <span style="color: #2e8b57;">10</span>)
(aif (<span style="color: #d18aff;">member</span> <span style="color: #2e8b57;">2</span> '(<span style="color: #2e8b57;">1</span> <span style="color: #2e8b57;">2</span> <span style="color: #2e8b57;">3</span>))
     (<span style="color: #d18aff;">displayln</span> it)
     (<span style="color: #d18aff;">void</span>))
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">(2 3)</span>
</pre>
</div>

<p>
The programmer wanted to print 10 but instead something else got
printed. This is a trivial example but quickly balloons with bigger
programs and bigger macros.
</p>

<p>
Let's instead use <code>syntax-parameters</code>. These can be used hygienically:
</p>

<div class="org-src-container">
<pre class="src src-racket">(<span style="color: #a1db00;">require</span> racket/stxparam)

(define-syntax-parameter <span style="color: #ff8700;">it</span> (<span style="color: #d18aff;">syntax-parser</span>))

(define-syntax-parser <span style="color: #ff8700;">aif</span>
  [(\<span style="color: #a1db00;">_</span> condition then otherwise)
   #'(<span style="color: #a1db00;">let</span> ([<span style="color: #ff8700;">t</span> condition])
       (syntax-parameterize ([it (<span style="color: #d18aff;">syntax-parser</span> [\<span style="color: #a1db00;">_</span> #<span style="color: #2e8b57;">'t</span>])])
         (<span style="color: #a1db00;">if</span> t then otherwise)))])

(aif (<span style="color: #d18aff;">member</span> <span style="color: #2e8b57;">2</span> '(<span style="color: #2e8b57;">1</span> <span style="color: #2e8b57;">2</span> <span style="color: #2e8b57;">3</span>))
     (<span style="color: #d18aff;">displayln</span> it)
     (<span style="color: #d18aff;">void</span>))
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">(2 3)</span>
</pre>
</div>

<p>
If we now have a declaration of it, that will override the syntax
parameter.
</p>

<div class="org-src-container">
<pre class="src src-racket">(<span style="color: #a1db00;">let</span> ([<span style="color: #ff8700;">it</span> <span style="color: #2e8b57;">10</span>])
  (aif (<span style="color: #d18aff;">member</span> <span style="color: #2e8b57;">2</span> '(<span style="color: #2e8b57;">1</span> <span style="color: #2e8b57;">2</span> <span style="color: #2e8b57;">3</span>))
       (<span style="color: #d18aff;">displayln</span> it)
       (<span style="color: #d18aff;">void</span>)))
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">10</span>
</pre>
</div>

<p>
During normal racket evaluation (from a file) you'll get a
<code>duplicate-identifier</code> error, in this context there's another error, but
the point is that there is an error instead of letting the programmer
scratch his head.
</p>

<div class="org-src-container">
<pre class="src src-racket">(<span style="color: #a1db00;">define</span> <span style="color: #ff8700;">it</span> <span style="color: #2e8b57;">10</span>)
(aif (<span style="color: #d18aff;">member</span> <span style="color: #2e8b57;">2</span> '(<span style="color: #2e8b57;">1</span> <span style="color: #2e8b57;">2</span> <span style="color: #2e8b57;">3</span>))
     (<span style="color: #d18aff;">displayln</span> it)
     (<span style="color: #d18aff;">void</span>))
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">eval:53:0: syntax-parameterize: not bound as a syntax</span>
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">parameter</span>
<span style="color: #6c6c6c; font-style: italic;">;;   </span><span style="color: #6c6c6c; font-style: italic;">at: it</span>
<span style="color: #6c6c6c; font-style: italic;">;;   </span><span style="color: #6c6c6c; font-style: italic;">in: (syntax-parameterize ((it (syntax-parser (\_ (syntax</span>
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">t))))) (if t (displayln it) (void)))</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org313156d" class="outline-2">
<h2 id="org313156d"><span class="section-number-2">13</span> I don't get it, how does <code>syntax-parse</code> work?</h2>
<div class="outline-text-2" id="text-13">
<p>
<code>syntax-parse</code> works by <b>replacing</b> <span class="underline">all syntax objects after the pattern
match</span> with the results from the pattern match:
</p>

<div class="org-src-container">
<pre class="src src-racket">(<span style="color: #d18aff;">syntax-parse</span> #'(<span style="color: #d18aff;">this</span> is some <span style="color: #a1db00;">syntax</span>)
  [(here is the pattern) #'(pattern is put here)])
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">#&lt;syntax:58:0 (syntax is put this)&gt;</span>
</pre>
</div>

<p>
<code>put</code> is <span class="underline"><b>not</b> in the pattern</span>, so it's just pasted <i>as-is</i>.
</p>

<p>
Another cool thing is that you can run arbitrary code in the body:
</p>

<div class="org-src-container">
<pre class="src src-racket">(<span style="color: #d18aff;">syntax-parse</span> #'(<span style="color: #d18aff;">this</span> is some <span style="color: #a1db00;">syntax</span>)
  [(here is the pattern)
   (<span style="color: #d18aff;">displayln</span> <span style="color: #ff4ea3;">"This is arbitrary code, we could download webpages for use in this macro, whatever you wish"</span>)
   #'(pattern is put here)])

<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">This is arbitrary code, we could download webpages for use in this macro, whatever you wish</span>
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">#&lt;syntax:59:0 (syntax is put this)&gt;</span>
</pre>
</div>

<p>
There are also some special pattern forms:
</p>

<div class="org-src-container">
<pre class="src src-racket">(<span style="color: #d18aff;">syntax-parse</span> #'(<span style="color: #d18aff;">this</span> is some <span style="color: #a1db00;">syntax</span>)
  [(here <span style="color: #a1db00;">...</span>) #'(here <span style="color: #a1db00;">...</span> put stuff)])
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">#&lt;syntax:60:0 (this is some syntax put stuff)&gt;</span>
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">syntax</th>
<th scope="col" class="org-left">description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>...</code></td>
<td class="org-left">a postfix operator that makes <code>syntax-parse</code> consider whatever is before as a list of that pattern. It will expand this list in the expander when it is encountered. This allows us to create pretty complex macros</td>
</tr>

<tr>
<td class="org-left"><code>...+</code></td>
<td class="org-left">means one or more.</td>
</tr>
</tbody>
</table>

<div class="org-src-container">
<pre class="src src-racket">(<span style="color: #d18aff;">syntax-parse</span> #'((<span style="color: #d18aff;">this</span> is) (some <span style="color: #a1db00;">syntax</span>))
  [((here there) ...+) #'(here <span style="color: #a1db00;">...</span> there <span style="color: #a1db00;">...</span> put stuff)])
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">#&lt;syntax:61:0 (this some is syntax put stuff)&gt;</span>
</pre>
</div>

<p>
They can even be nested
</p>

<div class="org-src-container">
<pre class="src src-racket">(<span style="color: #d18aff;">syntax-parse</span> #'((<span style="color: #d18aff;">this</span> is) (some more stuff <span style="color: #a1db00;">syntax</span>))
  [((here <span style="color: #a1db00;">...</span> there) ...+) #'(here <span style="color: #a1db00;">...</span> <span style="color: #a1db00;">...</span> there <span style="color: #a1db00;">...</span> put stuff)])
<span style="color: #6c6c6c; font-style: italic;">;; </span><span style="color: #6c6c6c; font-style: italic;">#&lt;syntax:62:0 (this some more stuff is synt...&gt;</span>
</pre>
</div>

<p>
Note that the <code>...</code> operator in the syntax has left-associativity, so:
</p>
<ul class="org-ul">
<li><code>here ... ...</code> <i>reduces to</i> (in this case) <code>((this) (some more stuff)) ...  ...</code></li>
<li>which <i>reduces to</i> <code>(this) ... (some more stuff) ...</code></li>
<li>which <i>reduces to</i> <code>this some more stuff</code></li>
</ul>
</div>
</div>

<div id="outline-container-org918dfd1" class="outline-2">
<h2 id="org918dfd1"><span class="section-number-2">14</span> Read the original article <a href="https://kevin.stravers.net/2017/11/practical-macros-in-racket-and-how-to-work-with-them.html">here</a>.</h2>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2017-11-17 Fri 00:00</p>
<p class="author">Author: Kevin R. Stravers</p>
<p class="date">Created: 2018-10-14 Sun 18:48</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>